# Deploy self-hosted agents using Helm (ensures KEDA is installed)
trigger: none
pr: none

parameters:
  - name: deployLinux
    type: boolean
    default: true
  - name: deployWindows
    type: boolean
    default: true
  - name: windowsVersion
    type: string
    default: "2022"
  - name: windowsImageVariant
    type: string
    default: "dind"
    values:
      - "dind"
      - "docker"
  - name: linuxImageVariant
    type: string
    default: "dind"
  - name: AZURE_SERVICE_CONNECTION
    type: string
    default: "SvcConnRgScopedProd"
    values:
      - "SvcConnRgScopedProd"
  - name: ACR_NAME
    type: string
    default: "cragents0036o3yuvhlr3ygc"
    values:
      - "cragents0036o3yuvhlr3ygc"
  - name: attachAcr
    type: boolean
    default: false
  - name: skipLinux
    type: boolean
    default: false
  - name: useAzureLocal
    type: boolean
    default: false
  - name: azureDevOpsOrgUrl
    type: string
    default: "https://dev.azure.com/devops-halo"
  - name: instanceNumber
    type: string
    default: "003"
  - name: bootstrapPoolName
    type: string
    default: "KubernetesPoolWindows"
  - name: windowsOnPremPoolName
    type: string
    default: "WindowsLatestPoolOnPrem"
  - name: ubuntuOnPremPoolName
    type: string
    default: "UbuntuLatestPoolOnPrem"
  # Removed hardcoded 001 from parameters, will calculate below
  - name: windowsNodeTaintKey
    type: string
    default: "sku"
    displayName: "Windows node taint key to require (default: 'sku' to match Helm chart toleration)"
  - name: windowsNodeTaintEffect
    type: string
    default: "NoSchedule"
    displayName: "Taint effect to require on Windows nodes (default: NoSchedule)"
  - name: windowsNodeTaintValue
    type: string
    default: "Windows"
    displayName: "Taint value to require on Windows nodes (default: 'Windows' to match Helm chart)"
  - name: useOnPremAgents
    type: boolean
    default: false # Set to true to use on-premises agents, false to use cloud agents

variables:
  - ${{ if eq(parameters.useAzureLocal, true) }}:
      - group: "ADO_az-devops-agents-k8s-002-azurelocal" # to get AZDO_PAT
  - ${{ if ne(parameters.useAzureLocal, true) }}:
      - group: "ADO_az-devops-agents-k8s-002" # to get AZDO_PAT
  - name: instanceNumber
    value: ${{ parameters.instanceNumber }}
  - name: aksResourceGroup
    value: rg-aks-ado-agents-${{ variables.instanceNumber }}
  - name: aksClusterName
    value: aks-ado-agents-${{ variables.instanceNumber }}
  - name: kubeconfigAzureLocal
    value: workload-cluster-${{ variables.instanceNumber }}-kubeconfig.yaml
  - ${{ if eq(parameters.useAzureLocal, true) }}:
      - name: kubeConfigSecretFile
        value: AKS_workload-cluster-${{ variables.instanceNumber }}-kubeconfig_file-azurelocal
  - ${{ if ne(parameters.useAzureLocal, true) }}:
      - name: kubeConfigSecretFile
        value: AKS_workload-cluster-${{ variables.instanceNumber }}-kubeconfig_file
  - name: kubeContextAzureLocal
    value: workload-cluster-${{ variables.instanceNumber }}-admin@workload-cluster-${{ variables.instanceNumber }}
  - name: azureSubscription
    value: ${{ parameters.AZURE_SERVICE_CONNECTION }}

stages:
  - stage: DeployHelm
    displayName: Deploy via Helm (install KEDA)
    jobs:
      - job: HelmDeploy
        displayName: Deploy agents Helm chart
        pool:
          ${{ if eq(parameters.useAzureLocal, true) }}:
            ${{ if ne(parameters.bootstrapPoolName, '') }}:
              name: ${{ parameters.bootstrapPoolName }}
            ${{ else }}:
              name: ${{ parameters.windowsOnPremPoolName }}
          ${{ if and(eq(parameters.useAzureLocal, false), eq(parameters.useOnPremAgents, true)) }}:
            name: ${{ parameters.ubuntuOnPremPoolName }}
          ${{ if and(eq(parameters.useAzureLocal, false), ne(parameters.useOnPremAgents, true)) }}:
            vmImage: ubuntu-latest
        steps:
          - checkout: self

          - ${{ if eq(parameters.useAzureLocal, true) }}:
              - task: DownloadSecureFile@1
                name: DownloadKubeconfig
                displayName: Download AKS kubeconfig (secure file)
                inputs:
                  secureFile: ${{ variables.kubeConfigSecretFile }}
          - ${{ if eq(parameters.useAzureLocal, false) }}:
              - task: AzureCLI@2
                displayName: Fetch AKS credentials (az aks get-credentials)
                inputs:
                  azureSubscription: $(azureSubscription)
                  scriptType: bash
                  scriptLocation: inlineScript
                  inlineScript: |
                    set -euo pipefail
                    RG="$(aksResourceGroup)"
                    CLUSTER="$(aksClusterName)"
                    if [ -z "$RG" ] || [ -z "$CLUSTER" ]; then
                      echo "AKS resource group or cluster name not provided. Provide aksResourceGroup and aksClusterName when useAzureLocal is false."
                      exit 1
                    fi
                    KCFG="$AGENT_TEMPDIRECTORY/kubeconfig"
                    echo "Fetching AKS credentials for $CLUSTER in $RG into $KCFG"
                    az aks get-credentials --resource-group "$RG" --name "$CLUSTER" --file "$KCFG" --overwrite-existing
                    echo "##vso[task.setvariable variable=KUBECONFIG]$KCFG"

              - ${{ if eq(parameters.attachAcr, true) }}:
                  - task: AzureCLI@2
                    displayName: Attach ACR to AKS (optional)
                    enabled: true
                    inputs:
                      azureSubscription: $(azureSubscription)
                      scriptType: bash
                      scriptLocation: inlineScript
                      inlineScript: |
                        set -euo pipefail
                        RG="$(aksResourceGroup)"
                        CLUSTER="$(aksClusterName)"
                        if [ -z "$RG" ] || [ -z "$CLUSTER" ]; then
                          echo "AKS resource group or cluster name not provided. Provide aksResourceGroup and aksClusterName when useAzureLocal is false."
                          exit 1
                        fi
                        ACR_NAME="${{ parameters.ACR_NAME }}"
                        echo "Checking whether ACR '$ACR_NAME' is already attached to AKS cluster '$CLUSTER' in resource group '$RG'"

                        # Determine the cluster's principalId (managed identity) or fall back to service principal clientId
                        principalId=$(az aks show -g "$RG" -n "$CLUSTER" --query "identity.principalId" -o tsv 2>/dev/null || true)
                        if [ -z "$principalId" ] || [ "$principalId" = "null" ]; then
                          principalId=$(az aks show -g "$RG" -n "$CLUSTER" --query "servicePrincipalProfile.clientId" -o tsv 2>/dev/null || true)
                        fi

                        need_attach=1
                        if [ -n "$principalId" ] && [ "$principalId" != "null" ]; then
                          # Resolve ACR resource id if possible
                          acrId=$(az acr show -n "$ACR_NAME" --query id -o tsv 2>/dev/null || true)
                          if [ -z "$acrId" ]; then
                            # If ACR_NAME looks like a resource id, use it
                            if echo "$ACR_NAME" | grep -q "/subscriptions/"; then
                              acrId="$ACR_NAME"
                            else
                              echo "Warning: could not resolve ACR resource id for '$ACR_NAME' - will attempt attach (az will validate)."
                              acrId=""
                            fi
                          fi

                          if [ -n "$acrId" ]; then
                            # Check for any role assignment for this principal on the ACR scope
                            assignCount=$(az role assignment list --assignee "$principalId" --scope "$acrId" --query "length([])" -o tsv 2>/dev/null || echo 0)
                            if [ -n "$assignCount" ] && [ "$assignCount" -gt 0 ]; then
                              echo "Found existing role assignment(s) between AKS principal ($principalId) and ACR ($acrId). Skipping attach."
                              need_attach=0
                            else
                              echo "No role assignment found between AKS principal ($principalId) and ACR ($acrId). Will attach."
                              need_attach=1
                            fi
                          else
                            # If we couldn't resolve acrId, be conservative and attach
                            need_attach=1
                          fi
                        else
                          echo "Could not determine AKS cluster principalId/servicePrincipalProfile; proceeding to attach ACR to be safe."
                          need_attach=1
                        fi

                        if [ "$need_attach" -eq 1 ]; then
                          echo "Attaching ACR '$ACR_NAME' to AKS cluster '$CLUSTER' in resource group '$RG'"
                          az aks update --resource-group "$RG" --name "$CLUSTER" --attach-acr "$ACR_NAME"
                        else
                          echo "Skipping az aks update --attach-acr because cluster already has access to ACR."
                        fi

          - task: HelmInstaller@1
            enabled: false
            displayName: Install Helm client
            inputs:
              helmVersionToInstall: "latest" # will install 4 alpha!!

          - task: PowerShell@2
            displayName: Prepare kubeconfig & ensure kubectl in PATH
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                # If a secure file downloader ran earlier it will populate DownloadKubeconfig.secureFilePath
                $requestedSecureFile = '${{ variables.kubeConfigSecretFile }}'
                if(-not [string]::IsNullOrWhiteSpace($requestedSecureFile)){
                  Write-Host "Expecting kubeconfig secure file named '$requestedSecureFile'"
                }
                $secureKubeConfig = '$(DownloadKubeconfig.secureFilePath)'
                if(-not [string]::IsNullOrWhiteSpace($secureKubeConfig) -and (Test-Path $secureKubeConfig)){
                  Write-Host "Secure file path resolved to $secureKubeConfig"
                  $kubeconfigPath = Join-Path $env:AGENT_TEMPDIRECTORY 'kubeconfig'
                  Copy-Item -Path $secureKubeConfig -Destination $kubeconfigPath -Force
                  Write-Host "Copied secure-file kubeconfig to $kubeconfigPath"
                  Write-Host "##vso[task.setvariable variable=KUBECONFIG]$kubeconfigPath"
                  Write-Host "Active kubeconfig set to $kubeconfigPath"
                } elseif(-not [string]::IsNullOrWhiteSpace($env:KUBECONFIG) -and (Test-Path $env:KUBECONFIG)){
                  Write-Host "KUBECONFIG already set to $env:KUBECONFIG (from previous az aks get-credentials step)"
                } else {
                  throw 'No kubeconfig available: neither DownloadSecureFile produced a kubeconfig nor was KUBECONFIG previously set. Ensure useAzureLocal=true with a secure file, or provide aksResourceGroup/aksClusterName with useAzureLocal=false.'
                }
                $kubectlCmd = Get-Command kubectl -ErrorAction SilentlyContinue
                if(-not $kubectlCmd){
                  Write-Host 'kubectl not found on PATH; downloading...'
                  $url = 'https://dl.k8s.io/release/v1.29.4/bin/linux/amd64/kubectl'
                  $kubectlPath = Join-Path $env:AGENT_TEMPDIRECTORY 'kubectl'
                  Invoke-WebRequest -Uri $url -OutFile $kubectlPath
                  chmod +x $kubectlPath
                  Write-Host "##vso[task.prependpath]$($env:AGENT_TEMPDIRECTORY)"
                  Write-Host "Downloaded kubectl to $kubectlPath and prepended AGENT_TEMPDIRECTORY to PATH"
                } else { Write-Host "kubectl found at $($kubectlCmd.Path)" }

          - ${{ if eq(parameters.deployWindows, true) }}:
              - task: PowerShell@2
                displayName: Verify Windows nodes and NoSchedule taints
                inputs:
                  targetType: inline
                  pwsh: true
                  script: |
                    Set-StrictMode -Version Latest
                    $ErrorActionPreference = 'Stop'
                    # Ensure KUBECONFIG is present
                    if (-not $env:KUBECONFIG -or -not (Test-Path $env:KUBECONFIG)) {
                      Write-Error "KUBECONFIG not set or not found at '$env:KUBECONFIG'. Cannot query cluster to verify Windows nodes."
                      exit 1
                    }
                    Write-Host "Querying cluster for nodes using KUBECONFIG=$env:KUBECONFIG"
                    # Run repository helper to dump taints for debugging/visibility
                    $repoRoot = "$(System.DefaultWorkingDirectory)"
                    $getTaintsScript = Join-Path $repoRoot 'azsh-windows-agent\Get-Taints.ps1'
                    if (Test-Path $getTaintsScript) {
                      Write-Host "Running helper: $getTaintsScript"
                      try { pwsh -NoProfile -NonInteractive -File $getTaintsScript } catch { Write-Warning ("Get-Taints helper failed: {0}" -f $_.Exception.Message) }
                    }

                    $nodesJson = kubectl --kubeconfig $env:KUBECONFIG get nodes -o json 2>$null
                    if (-not $nodesJson) { Write-Error 'Failed to list nodes from cluster (kubectl returned no output)'; exit 1 }
                    $nodes = $nodesJson | ConvertFrom-Json
                    $windowsNodes = @()
                    foreach ($n in $nodes.items) {
                      $osLabel = $n.metadata.labels.'kubernetes.io/os'
                      if ($osLabel -and $osLabel -eq 'windows') { $windowsNodes += $n }
                    }
                    if (-not $windowsNodes -or $windowsNodes.Count -eq 0) {
                      Write-Error 'No Windows nodes found in the cluster. Ensure Windows agent nodes are provisioned before enabling Windows deploy.'
                      exit 1
                    }
                    Write-Host "Found $($windowsNodes.Count) Windows node(s): $(( $windowsNodes | ForEach-Object { $_.metadata.name } ) -join ', ')"
                    # Verify each windows node has a taint matching the configured effect/key
                    $taintKey = '${{ parameters.windowsNodeTaintKey }}'
                    $taintEffect = '${{ parameters.windowsNodeTaintEffect }}'
                    $taintValue = '${{ parameters.windowsNodeTaintValue }}'
                    if (-not $taintValue) { $taintValue = 'Windows' }
                    if (-not $taintEffect) { $taintEffect = 'NoSchedule' }
                    # Verify each windows node has a taint with the requested effect (and key if provided)
                    $missing = @()
                    foreach ($n in $windowsNodes) {
                      $name = $n.metadata.name
                      $taints = $null
                      try { $taints = $n.spec.taints } catch { $taints = $null }
                      $hasNoSchedule = $false
                      if ($taints) {
                        foreach ($t in $taints) {
                          # If a taint key and value are configured, require exact key+value+effect match (case-sensitive)
                          if ($taintKey -and $taintValue) {
                            if ($t.key -and $t.key -eq $taintKey -and $t.value -and $t.value -eq $taintValue -and $t.effect -and $t.effect -eq $taintEffect) { $hasNoSchedule = $true; break }
                          }
                          elseif ($taintKey -and -not $taintValue) {
                            # key configured but no value required: accept key+effect
                            if ($t.key -and $t.key -eq $taintKey -and $t.effect -and $t.effect -eq $taintEffect) { $hasNoSchedule = $true; break }
                          }
                          else {
                            # No key required: accept any taint with the required effect
                            if ($t.effect -and $t.effect -eq $taintEffect) { $hasNoSchedule = $true; break }
                          }
                        }
                      }
                      if (-not $hasNoSchedule) { $missing += $name }
                    }
                    if ($missing.Count -gt 0) {
                      Write-Warning "The following Windows nodes are missing a taint with effect '$taintEffect' (and key '$taintKey' if configured): $($missing -join ', '). Attempting to add taints automatically..."
                      # Attempt to add taints automatically and re-check
                      foreach ($nodeName in $missing) {
                        $tKey = $taintKey; if (-not $tKey) { $tKey = 'os' }
                        $taintValue = '${{ parameters.windowsNodeTaintValue }}'
                        if (-not $taintValue) { $taintValue = 'Windows' }
                        $taintArg = "{0}={1}:{2}" -f $tKey, $taintValue, $taintEffect
                        Write-Host ("Applying taint to {0}: {1}" -f $nodeName, $taintArg)
                        try {
                          kubectl --kubeconfig $env:KUBECONFIG taint nodes $nodeName $taintArg --overwrite
                          Write-Host "Taint applied to $nodeName"
                        }
                        catch {
                          Write-Warning ("Failed to apply taint to {0}: {1}" -f $nodeName, $_.Exception.Message)
                        }
                      }

                      # Requery nodes and re-evaluate
                      Write-Host 'Re-checking nodes after attempting to add taints...'
                      $nodesJson2 = kubectl --kubeconfig $env:KUBECONFIG get nodes -o json 2>$null
                      if (-not $nodesJson2) { Write-Error 'Failed to list nodes from cluster after taint attempt'; exit 1 }
                      $nodes2 = $nodesJson2 | ConvertFrom-Json
                      $windowsNodes2 = @()
                      foreach ($n in $nodes2.items) { if ($n.metadata.labels.'kubernetes.io/os' -eq 'windows') { $windowsNodes2 += $n } }
                      $missing2 = @()
                      foreach ($n in $windowsNodes2) {
                        $name = $n.metadata.name
                        $taints = $null
                        try { $taints = $n.spec.taints } catch { $taints = $null }
                        $hasTaint = $false
                        if ($taints) {
                          foreach ($t in $taints) {
                              if ($taintKey -and $taintValue) {
                                if ($t.key -and $t.key -eq $taintKey -and $t.value -and $t.value -eq $taintValue -and $t.effect -and $t.effect -eq $taintEffect) { $hasTaint = $true; break }
                              }
                              elseif ($taintKey -and -not $taintValue) {
                                if ($t.key -and $t.key -eq $taintKey -and $t.effect -and $t.effect -eq $taintEffect) { $hasTaint = $true; break }
                              }
                              else {
                                if ($t.effect -and $t.effect -eq $taintEffect) { $hasTaint = $true; break }
                              }
                            }
                        }
                        if (-not $hasTaint) { $missing2 += $name }
                      }
                      if ($missing2.Count -gt 0) {
                        $exampleKey = $taintKey; if (-not $exampleKey) { $exampleKey = 'os' }
                        $exampleValue = '${{ parameters.windowsNodeTaintValue }}'
                        if (-not $exampleValue) { $exampleValue = 'Windows' }
                        Write-Error ("After attempting to add taints, the following Windows nodes still lack the required taint: {0}.\nPlease taint them (example): kubectl taint nodes <node-name> {1}={2}:{3}" -f ($missing2 -join ', '), $exampleKey, $exampleValue, $taintEffect)
                        exit 1
                      }
                      else { Write-Host 'Taints applied (or already present) on all Windows nodes.' }
                    }
                    Write-Host 'Windows nodes verified and have NoSchedule taints.'

              - ${{ if eq(parameters.windowsImageVariant, 'dind') }}:
                  - task: PowerShell@2
                    displayName: Install Docker Engine on Windows nodes (DinD requirement)
                    env:
                      KUBECONFIG: $(KUBECONFIG)
                    inputs:
                      targetType: inline
                      pwsh: true
                      script: |
                        Set-StrictMode -Version Latest
                        $ErrorActionPreference = 'Stop'
                        if (-not $env:KUBECONFIG -or -not (Test-Path $env:KUBECONFIG)) {
                          Write-Error "KUBECONFIG not set or not found. Cannot install Docker on nodes."; exit 1
                        }
                        $repoRoot = "$(System.DefaultWorkingDirectory)"
                        $installScript = Join-Path $repoRoot 'scripts\Install-DockerOnWindowsNodes.ps1'
                        if (-not (Test-Path $installScript)) {
                          Write-Error "Install-DockerOnWindowsNodes.ps1 not found at $installScript"; exit 1
                        }
                        Write-Host "Running Install-DockerOnWindowsNodes.ps1 to ensure Docker Engine is present on Windows nodes for DinD scenario..."
                        $instance = '${{ parameters.instanceNumber }}'
                        $namespace = "az-devops-windows-$instance"
                        try {
                          & pwsh -NoProfile -NonInteractive -File $installScript -Namespace $namespace -TimeoutSeconds 600 -Verbose
                          if ($LASTEXITCODE -ne 0) {
                            Write-Error "Install-DockerOnWindowsNodes.ps1 failed with exit code $LASTEXITCODE"; exit 1
                          }
                          Write-Host "Docker Engine installation completed successfully on Windows nodes."
                        }
                        catch {
                          Write-Error ("Failed to install Docker on Windows nodes: {0}" -f $_.Exception.Message); exit 1
                        }

          - ${{ if eq(parameters.useAzureLocal, true) }}:
              - task: PowerShell@2
                displayName: Create Docker regsecret in target namespaces (on-prem)
                env:
                  KUBECONFIG: $(KUBECONFIG)
                  ACR_NAME: ${{ parameters.ACR_NAME }}
                  ACR_USERNAME: $(ACR_USERNAME)
                  ACR_PASSWORD: $(ACR_PASSWORD)
                inputs:
                  targetType: inline
                  pwsh: true
                  script: |
                    Set-StrictMode -Version Latest
                    $ErrorActionPreference = 'Stop'
                    if (-not $env:KUBECONFIG -or -not (Test-Path $env:KUBECONFIG)) {
                      Write-Host 'KUBECONFIG not set or missing; ensure DownloadSecureFile step ran and produced a kubeconfig'; exit 0
                    }
                    if (-not $env:ACR_USERNAME -or -not $env:ACR_PASSWORD) {
                      Write-Error 'ACR credentials not provided (ACR_USERNAME/ACR_PASSWORD variables empty); required when useAzureLocal=true. Failing the job.'; exit 1
                    }
                    # Detect unresolved pipeline macro placeholders like '$(ACR_USERNAME)' which indicate
                    # the pipeline variable wasn't set/expanded. Fail early to avoid creating a secret
                    # containing the literal macro string.
                    if ($env:ACR_USERNAME -and ($env:ACR_USERNAME -match '\$\(|\$\{')) {
                      Write-Error "ACR_USERNAME appears to contain an unresolved pipeline macro ('$($env:ACR_USERNAME)'). Ensure ACR_USERNAME is defined as a pipeline variable (secret) when useAzureLocal=true."; exit 1
                    }
                    if ($env:ACR_PASSWORD -and ($env:ACR_PASSWORD -match '\$\(|\$\{')) {
                      Write-Error "ACR_PASSWORD appears to contain an unresolved pipeline macro ('$([System.String]::Copy($env:ACR_PASSWORD))'). Ensure ACR_PASSWORD is defined as a pipeline variable (secret) when useAzureLocal=true."; exit 1
                    }
                    $instance = '${{ parameters.instanceNumber }}'
                    # Respect pipeline parameters for platform selection
                    $deployLinux = $false; try { $deployLinux = [System.Convert]::ToBoolean('${{ parameters.deployLinux }}') } catch { }
                    $deployWindows = $false; try { $deployWindows = [System.Convert]::ToBoolean('${{ parameters.deployWindows }}') } catch { }
                    $namespaces = @()
                    if ($deployLinux) { $namespaces += "az-devops-linux-$instance" }
                    if ($deployWindows) { $namespaces += "az-devops-windows-$instance" }
                    if ($namespaces.Count -eq 0) { Write-Host 'No target namespaces selected (deployLinux/deployWindows both false); nothing to do'; exit 0 }

                    # Helper to mask passwords for safe logging (preserve first 2 + last 2 chars)
                    function MaskString([string]$s) {
                      if (-not $s) { return '' }
                      if ($s.Length -le 4) { return '****' }
                      $mid = -join (1..($s.Length - 4) | ForEach-Object { '*' })
                      return $s.Substring(0,2) + $mid + $s.Substring($s.Length - 2)
                    }

                    foreach ($ns in $namespaces) {
                        try {
                          Write-Host "Ensuring namespace $ns exists"
                          kubectl --kubeconfig $env:KUBECONFIG create namespace $ns --dry-run=client -o yaml | kubectl --kubeconfig $env:KUBECONFIG apply -f -
                          Write-Host "Ensuring docker-registry secret 'regsecret' exists in namespace $ns"
                          kubectl --kubeconfig $env:KUBECONFIG create secret docker-registry regsecret --docker-server="$($env:ACR_NAME).azurecr.io" --docker-username="$($env:ACR_USERNAME)" --docker-password="$($env:ACR_PASSWORD)" -n $ns --dry-run=client -o yaml | kubectl --kubeconfig $env:KUBECONFIG apply -f -
                          Write-Host "regsecret ensured in $ns"
                          # Ensure the default serviceaccount in the namespace will use regsecret so pods without explicit
                          # imagePullSecrets inherit the ability to pull from the private registry.
                          try {
                            kubectl --kubeconfig $env:KUBECONFIG patch serviceaccount default -n $ns -p '{"imagePullSecrets":[{"name":"regsecret"}]}' --type=merge
                            Write-Host "Patched default serviceaccount in $ns to include regsecret"
                          }
                          catch {
                            Write-Warning (("Failed to patch default serviceaccount in {0}: {1}" -f $ns, $_.Exception.Message))
                          }

                          # Verification: decode the regsecret and print registry, username, and a masked password so
                          # pipeline logs can confirm the secret contents without exposing the raw password.
                          try {
                            $b64 = kubectl --kubeconfig $env:KUBECONFIG -n $ns get secret regsecret -o jsonpath='{.data.\.dockerconfigjson}' 2>$null
                            if ($b64) {
                              $jsonText = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($b64))
                              $obj = $jsonText | ConvertFrom-Json
                              $registry = ($obj.auths | Get-Member -MemberType NoteProperty | Select-Object -First 1).Name
                              $entry = $obj.auths.$registry
                              $username = $entry.username
                              $password = $entry.password
                              Write-Host ("regsecret verification - registry: {0}" -f $registry)
                              Write-Host ("regsecret verification - username: {0}" -f $username)
                              Write-Host ("regsecret verification - password (masked): {0}" -f (MaskString $password))
                            }
                            else { Write-Warning ("regsecret not found in {0} during verification" -f $ns) }
                          }
                          catch {
                            Write-Warning (("Failed to decode regsecret in {0}: {1}" -f $ns, $_.Exception.Message))
                          }
                        }
                        catch {
                          Write-Warning ("Failed to ensure regsecret in {0}: {1}" -f $ns, $_.Exception.Message)
                        }
                    }

          # Simplified: delegate pool creation, KEDA install, and Helm deployment to the repo script.
          # We keep kubeconfig preparation above; now invoke the single deploy helper with the
          # necessary parameters and environment variables.
          - task: PowerShell@2
            displayName: Assert ACR_NAME matches pipeline parameter
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $paramAcr = '${{ parameters.ACR_NAME }}'
                $envAcr = $env:ACR_NAME
                if (-not $paramAcr -or [string]::IsNullOrWhiteSpace($paramAcr)) {
                  Write-Error "Pipeline parameter ACR_NAME is empty. Ensure the pipeline passes ACR_NAME parameter."; exit 1
                }
                if (-not $envAcr -or [string]::IsNullOrWhiteSpace($envAcr)) {
                  Write-Host "Pipeline environment variable ACR_NAME is empty; setting it from pipeline parameter."
                  Write-Host "##vso[task.setvariable variable=ACR_NAME]$paramAcr"
                  Write-Host "ACR_NAME set to $paramAcr"
                }
                elseif ($envAcr -ne $paramAcr) {
                  Write-Error "ACR_NAME mismatch: pipeline parameter value='$paramAcr' but environment ACR_NAME='$envAcr'. Aborting."; exit 1
                }
                else {
                  Write-Host "ACR_NAME assertion passed: $envAcr"
                }

          - task: PowerShell@2
            displayName: Deploy agents (via repo script wrapper)
            env:
              KUBECONFIG: $(KUBECONFIG)
              ACR_NAME: ${{ parameters.ACR_NAME }}
              PIPELINE_ACR_NAME: ${{ parameters.ACR_NAME }}
              AZDO_PAT: $(AZDO_PAT)
              ACR_USERNAME: $(ACR_USERNAME)
              ACR_PASSWORD: $(ACR_PASSWORD)
              INSTANCE_NUMBER: "${{ parameters.instanceNumber }}"
              DEPLOY_LINUX: $(DEPLOY_LINUX)
              LINUX_IMAGE_VARIANT: "${{ parameters.linuxImageVariant }}"
              DEPLOY_WINDOWS: "${{ parameters.deployWindows }}"
              WINDOWS_IMAGE_VARIANT: "${{ parameters.windowsImageVariant }}"
              AZDO_ORG_URL: "${{ parameters.azureDevOpsOrgUrl }}"
              USE_AZURE_LOCAL: "${{ parameters.useAzureLocal }}"
              KUBECONFIG_AZURE_LOCAL: "${{ variables.kubeconfigAzureLocal }}"
              KUBECONTEXT_AZURE_LOCAL: "${{ variables.kubeContextAzureLocal }}"
            inputs:
              targetType: filePath
              ${{ if eq(parameters.useAzureLocal, true) }}:
                arguments: "-UseAzureLocal"
              # Use POSIX-style forward slashes so the path resolves correctly on linux agents
              filePath: "$(Build.SourcesDirectory)/.azuredevops/scripts/run-deploy-selfhosted-agents-helm.ps1"
              pwsh: true

          - task: PowerShell@2
            displayName: Compute DEPLOY_LINUX variable
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $deployLinuxParam = [System.Convert]::ToBoolean('${{ parameters.deployLinux }}')
                $skipLinuxParam = [System.Convert]::ToBoolean('${{ parameters.skipLinux }}')
                $deployLinux = ($deployLinuxParam -and -not $skipLinuxParam)
                Write-Host "Computed deployLinux (deployLinuxParam=$deployLinuxParam, skipLinuxParam=$skipLinuxParam) => $deployLinux"
                Write-Host "##vso[task.setvariable variable=DEPLOY_LINUX]$deployLinux"

          - task: PowerShell@2
            name: SetHelmOutputs
            displayName: Set Helm release outputs (for Summary job)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $instance = '${{ parameters.instanceNumber }}'
                if([string]::IsNullOrWhiteSpace($instance)){ $instance = '${{ parameters.instanceNumber }}' }
                $releaseName = "az-selfhosted-agents-$instance"
                # determine namespace selection same as the repo script
                $deployLinuxRaw = '${{ parameters.deployLinux }}'
                $deployWindowsRaw = '${{ parameters.deployWindows }}'
                $deployLinux = $false; if($deployLinuxRaw -match '^[Tt]rue$|^1$'){ $deployLinux = $true }
                $deployWindows = $false; if($deployWindowsRaw -match '^[Tt]rue$|^1$'){ $deployWindows = $true }
                $releaseNamespace = if($deployLinux){ "az-devops-linux-$instance" } elseif($deployWindows){ "az-devops-windows-$instance" } else { "az-devops-linux-$instance" }
                Write-Host "##vso[task.setvariable variable=HELM_RELEASE_NAME;isOutput=true]$releaseName"
                Write-Host "##vso[task.setvariable variable=HELM_RELEASE_NAMESPACE;isOutput=true]$releaseNamespace"

          - task: PublishPipelineArtifact@1
            displayName: Publish helm values override
            inputs:
              targetPath: "$(Build.ArtifactStagingDirectory)/helm-values-override.yaml"
              artifact: helm-values

          - task: PowerShell@2
            displayName: Post-deploy verification
            env:
              KUBECONFIG: $(KUBECONFIG)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                Write-Host 'KEDA pods:'
                try { kubectl get pods -n keda -o wide } catch { Write-Warning ("Failed to list KEDA pods: {0}" -f $_.Exception.Message) }
                $inst = '${{ parameters.instanceNumber }}'; if([string]::IsNullOrWhiteSpace($inst)){ $inst='${{ parameters.instanceNumber }}' }
                $linuxNs = "az-devops-linux-$inst"
                $winNs = "az-devops-windows-$inst"
                Write-Host "Note: az-devops-$inst is deprecated; showing per-OS namespaces instead."

                # Fail the pipeline if any pod in the target release namespace is in ImagePullBackOff or ErrImagePull
                $releaseNamespace = if([System.Convert]::ToBoolean('${{ parameters.deployLinux }}')) { $linuxNs } elseif([System.Convert]::ToBoolean('${{ parameters.deployWindows }}')) { $winNs } else { $linuxNs }
                try {
                  $bad = kubectl get pods -n $releaseNamespace --no-headers -o custom-columns=STATUS:.status.containerStatuses[*].state -A 2>$null | Select-String 'ImagePullBackOff|ErrImagePull' -Quiet
                  if ($bad) {
                    Write-Error "Detected ImagePullBackOff/ErrImagePull in namespace $releaseNamespace. Failing pipeline to surface image pull issues."
                    exit 1
                  }
                }
                catch {
                  Write-Warning ("Failed to inspect pod statuses in {0}: {1}" -f $releaseNamespace, $_.Exception.Message)
                }
                Write-Host "Deploy namespace $releaseNamespace appears healthy (no ImagePullBackOff/ErrImagePull detected)."

      - job: Summary
        displayName: Summary
        dependsOn: HelmDeploy
        condition: succeededOrFailed()
        pool:
          ${{ if or(eq(parameters.useAzureLocal, true), eq(parameters.useOnPremAgents, true)) }}:
            name: ${{ parameters.ubuntuOnPremPoolName }}
          ${{ if and(ne(parameters.useAzureLocal, true), ne(parameters.useOnPremAgents, true)) }}:
            vmImage: ubuntu-latest
        steps:
          - task: PowerShell@2
            displayName: Generate config artifact (for validation pipeline)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $config = [ordered]@{
                  instanceNumber    = '${{ parameters.instanceNumber }}'
                  deployLinux       = $${{ parameters.deployLinux }}
                  deployWindows     = $${{ parameters.deployWindows }}
                  azureDevOpsOrgUrl = '${{ parameters.azureDevOpsOrgUrl }}'
                  windowsVersion    = '${{ parameters.windowsVersion }}'
                  windowsImageVariant = '${{ parameters.windowsImageVariant }}'
                  linuxImageVariant = '${{ parameters.linuxImageVariant }}'
                  useAzureLocal     = $${{ parameters.useAzureLocal }}
                } | ConvertTo-Json -Depth 5
                $path = Join-Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY 'config.json'
                $config | Out-File $path -Encoding utf8
                Write-Host "Wrote config to $path"
          - task: PublishPipelineArtifact@1
            displayName: Publish agent config artifact
            inputs:
              targetPath: "$(Build.ArtifactStagingDirectory)/config.json"
              artifact: agent-config
              publishLocation: pipeline
          - task: PowerShell@2
            displayName: Compute & attach resource name summary
            env:
              # runtime expression: inject the HelmDeploy job result into the task environment
              HELM_DEPLOY_RESULT: $[ dependencies.HelmDeploy.result ]
              # Read outputs from the HelmDeploy.SetHelmOutputs task (job-scoped output variables)
              HELM_RELEASE_NAME: $[ dependencies.HelmDeploy.outputs['SetHelmOutputs.HELM_RELEASE_NAME'] ]
              HELM_RELEASE_NAMESPACE: $[ dependencies.HelmDeploy.outputs['SetHelmOutputs.HELM_RELEASE_NAMESPACE'] ]
            inputs:
              targetType: inline
              pwsh: true
              script: |
                # Defensive summary: don't let unexpanded runtime tokens or missing helm/commands fail the task
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Continue'
                try {
                  $instance = '${{ parameters.instanceNumber }}'
                  if([string]::IsNullOrWhiteSpace($instance)){ $instance = '${{ parameters.instanceNumber }}' }
                  $useLocalParam = $false
                  try { $useLocalParam = [bool]('${{ parameters.useAzureLocal }}') } catch { $useLocalParam = $false }
                  if ($useLocalParam) { $linuxPool = "KubernetesPoolOnPremLinux$instance"; $windowsPool = "KubernetesPoolOnPremWindows$instance" } else { $linuxPool = "KubernetesPoolLinux$instance"; $windowsPool = "KubernetesPoolWindows$instance" }
                  $linuxNamespace   = "az-devops-linux-$instance"
                  $windowsNamespace = "az-devops-windows-$instance"
                  $linuxSecret      = "linux-sh-agent-secret-$instance"
                  $linuxDeployment  = "linux-sh-agent-deployment-$instance"
                  $windowsSecret    = "windows-sh-agent-secret-$instance"
                  $windowsDeployment= "windows-sh-agent-deployment-$instance"

                  # Read the injected helm deploy result from the environment (may be an unexpanded runtime token)
                  $linuxResult = $env:HELM_DEPLOY_RESULT
                  if([string]::IsNullOrWhiteSpace($linuxResult)){
                    $linuxResult = 'Unknown'
                  }
                  # If runtime-expression tokens were passed verbatim (e.g. $[ dependencies... ]) replace with Unknown
                  if($linuxResult.Trim().StartsWith('$[')){
                    $linuxResult = 'Unknown'
                  }

                  $releaseName = $env:HELM_RELEASE_NAME
                  $releaseNamespace = $env:HELM_RELEASE_NAMESPACE
                  if([string]::IsNullOrWhiteSpace($releaseName) -or $releaseName.Trim().StartsWith('$[')){ $releaseName = 'az-selfhosted-agents' }
                  if([string]::IsNullOrWhiteSpace($releaseNamespace) -or $releaseNamespace.Trim().StartsWith('$[')){ $releaseNamespace = "az-devops-linux-$instance" }

                  $lines = @(
                    '# Self-hosted Agents Deployment Resources',
                    '',
                    "**Instance Number:** $instance",
                    '',
                    '## Resource Names',
                    '| Resource Type | Linux | Windows |',
                    '|---------------|-------|---------|',
                    "| Namespace | $linuxNamespace | $windowsNamespace |",
                    "| Pool | $linuxPool | $windowsPool |",
                    "| Secret | $linuxSecret | $windowsSecret |",
                    "| Deployment | $linuxDeployment | $windowsDeployment |",
                    '',
                    '## Job Results',
                    "* Linux Job Result: $linuxResult",
                    '',
                    '## Notes',
                    '- Resource names are derived; if a platform was skipped its Kubernetes objects may not exist yet.',
                    "- Adjust instanceNumber parameter to provision another isolated set."
                  )

                  $outPath = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'resource-summary.md'
                  $lines | Out-File $outPath -Encoding utf8
                  Write-Host "Summary markdown written to $outPath"
                  Write-Host "##vso[task.addattachment type=Distributedtask.Core.Summary;name=Deployment Resources]$outPath"
                  $lines | ForEach-Object { Write-Host $_ }

                  # If helm is available try to fetch the applied values for the release and attach them as an extra artifact
                  $helm = Get-Command helm -ErrorAction SilentlyContinue
                  if($helm){
                    try{
                      $values = & helm get values $releaseName -n $releaseNamespace -o yaml 2>$null
                      if(-not [string]::IsNullOrWhiteSpace($values)){
                        # Local helper to mask obvious secrets before writing to artifacts
                        function MaskSensitive([string]$text){
                          if(-not $text){ return $text }
                          $opts = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase -bor [System.Text.RegularExpressions.RegexOptions]::Multiline
                          # AZP tokens
                          $text = [regex]::Replace($text, '(?mi)^(\s*(?:AZP_TOKEN|AZP_TOKEN_VALUE)\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          # personalAccessToken
                          $text = [regex]::Replace($text, '(?mi)^(\s*personalAccessToken\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          # dockerconfigjson inline fields
                          $text = [regex]::Replace($text, '(?mi)("password"\s*:\s*")([^"]+)(")', '${1}(redacted)${3}', $opts)
                          $text = [regex]::Replace($text, '(?mi)("auth"\s*:\s*")([^"]+)(")', '${1}(redacted)${3}', $opts)
                          # generic password keys
                          $text = [regex]::Replace($text, '(?mi)^(\s*password\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          return $text
                        }
                        $valsPath = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'helm-applied-values.yaml'
                        $masked = MaskSensitive $values
                        $masked | Out-File $valsPath -Encoding utf8
                        Write-Host "Wrote masked helm applied values to $valsPath"
                        Write-Host "##vso[task.uploadfile]$valsPath"
                      }
                    } catch { Write-Host ("helm get values failed: {0}" -f $_.Exception.Message) }
                  } else { Write-Host 'helm client not found in PATH; skipping helm get values.' }
                } catch {
                  Write-Host ("Summary step encountered non-fatal error: {0}" -f $_.Exception.Message)
                } finally {
                  # Ensure this summary step never fails the pipeline
                  exit 0
                }

          - task: PowerShell@2
            displayName: Check for applied helm values file
            name: CheckHelmAppliedValues
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $path = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'helm-applied-values.yaml'
                if(Test-Path $path){
                  Write-Host "Found applied helm values at $path"
                  Write-Host "##vso[task.setvariable variable=HelmAppliedValuesExists]true"
                } else {
                  Write-Host "Applied helm values not found at $path"
                  Write-Host "##vso[task.setvariable variable=HelmAppliedValuesExists]false"
                }

          - task: PublishPipelineArtifact@1
            displayName: Publish applied helm values (if present)
            inputs:
              targetPath: "$(System.DefaultWorkingDirectory)/helm-applied-values.yaml"
              artifact: helm-applied-values
            condition: and(succeeded(), eq(variables['HelmAppliedValuesExists'], 'true'))
