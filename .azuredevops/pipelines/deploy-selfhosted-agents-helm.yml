# Deploy self-hosted agents using Helm (ensures KEDA is installed)
trigger: none
pr: none

parameters:
  - name: deployLinux
    type: boolean
    default: true
  - name: deployWindows
    type: boolean
    default: true
  - name: windowsVersion
    type: string
    default: "2022"
  - name: linuxImageVariant
    type: string
    default: "docker"
  - name: AZURE_SERVICE_CONNECTION
    type: string
    default: "DOS_DevOpsShield_Prod"
    values:
      - "DOS_DevOpsShield_Prod"
      - "ADO_SvcConnRgScopedProd"
  - name: ACR_NAME
    type: string
    default: "cragents003c66i4n7btfksg"
    values:
      - "cragents003c66i4n7btfksg"
      # legacy registry removed from options to avoid accidental selection
      # - "cragentssgvhe4aipy37o"
  - name: attachAcr
    type: boolean
    default: true
  - name: skipLinux
    type: boolean
    default: false
  - name: useAzureLocal
    type: boolean
    default: false
  - name: aksResourceGroup
    type: string
    default: "rg-aks-ado-agents-003"
  - name: aksClusterName
    type: string
    default: "aks-ado-agents-003"
  - name: azureDevOpsOrgUrl
    type: string
    default: "https://dev.azure.com/cad4devops"
  - name: instanceNumber
    type: string
    default: "003"
  - name: bootstrapPoolName
    type: string
    default: "KubernetesPoolWindows"
  - name: useOnPremAgents
    type: boolean
    default: true # Set to true to use on-premises agents, false to use cloud agents

variables:
  - group: ADO_az-devops-agents-k8s # to get AZDO_PAT
  - name: azureSubscription
    value: ${{ parameters.AZURE_SERVICE_CONNECTION }}

stages:
  - stage: DeployHelm
    displayName: Deploy via Helm (install KEDA)
    jobs:
      - job: HelmDeploy
        displayName: Deploy agents Helm chart
        pool:
          ${{ if eq(parameters.useAzureLocal, true) }}:
            ${{ if ne(parameters.bootstrapPoolName, '') }}:
              name: ${{ parameters.bootstrapPoolName }}
            ${{ if eq(parameters.bootstrapPoolName, '') }}:
              vmImage: ubuntu-latest
          ${{ if eq(parameters.useAzureLocal, false) }}:
            vmImage: ubuntu-latest
        steps:
          - checkout: self

          - ${{ if eq(parameters.useAzureLocal, true) }}:
              - task: DownloadSecureFile@1
                name: DownloadKubeconfig
                displayName: Download AKS kubeconfig (secure file)
                inputs:
                  secureFile: AKS_my-workload-cluster-dev-014-kubeconfig_file
          - ${{ if eq(parameters.useAzureLocal, false) }}:
              - task: AzureCLI@2
                displayName: Fetch AKS credentials (az aks get-credentials)
                inputs:
                  azureSubscription: $(azureSubscription)
                  scriptType: bash
                  scriptLocation: inlineScript
                  inlineScript: |
                    set -euo pipefail
                    if [ -z "${{ parameters.aksResourceGroup }}" ] || [ -z "${{ parameters.aksClusterName }}" ]; then
                      echo "AKS resource group or cluster name not provided. Provide aksResourceGroup and aksClusterName when useAzureLocal is false."
                      exit 1
                    fi
                    KCFG="$AGENT_TEMPDIRECTORY/kubeconfig"
                    echo "Fetching AKS credentials for ${{ parameters.aksClusterName }} in ${{ parameters.aksResourceGroup }} into $KCFG"
                    az aks get-credentials --resource-group "${{ parameters.aksResourceGroup }}" --name "${{ parameters.aksClusterName }}" --file "$KCFG" --overwrite-existing
                    echo "##vso[task.setvariable variable=KUBECONFIG]$KCFG"

              - ${{ if eq(parameters.attachAcr, true) }}:
                  - task: AzureCLI@2
                    displayName: Attach ACR to AKS (optional)
                    enabled: true
                    inputs:
                      azureSubscription: $(azureSubscription)
                      scriptType: bash
                      scriptLocation: inlineScript
                      inlineScript: |
                        set -euo pipefail
                        if [ -z "${{ parameters.aksResourceGroup }}" ] || [ -z "${{ parameters.aksClusterName }}" ]; then
                          echo "AKS resource group or cluster name not provided. Provide aksResourceGroup and aksClusterName when useAzureLocal is false."
                          exit 1
                        fi
                        ACR_NAME="${{ parameters.ACR_NAME }}"
                        RG="${{ parameters.aksResourceGroup }}"
                        CLUSTER="${{ parameters.aksClusterName }}"
                        echo "Checking whether ACR '$ACR_NAME' is already attached to AKS cluster '$CLUSTER' in resource group '$RG'"

                        # Determine the cluster's principalId (managed identity) or fall back to service principal clientId
                        principalId=$(az aks show -g "$RG" -n "$CLUSTER" --query "identity.principalId" -o tsv 2>/dev/null || true)
                        if [ -z "$principalId" ] || [ "$principalId" = "null" ]; then
                          principalId=$(az aks show -g "$RG" -n "$CLUSTER" --query "servicePrincipalProfile.clientId" -o tsv 2>/dev/null || true)
                        fi

                        need_attach=1
                        if [ -n "$principalId" ] && [ "$principalId" != "null" ]; then
                          # Resolve ACR resource id if possible
                          acrId=$(az acr show -n "$ACR_NAME" --query id -o tsv 2>/dev/null || true)
                          if [ -z "$acrId" ]; then
                            # If ACR_NAME looks like a resource id, use it
                            if echo "$ACR_NAME" | grep -q "/subscriptions/"; then
                              acrId="$ACR_NAME"
                            else
                              echo "Warning: could not resolve ACR resource id for '$ACR_NAME' - will attempt attach (az will validate)."
                              acrId=""
                            fi
                          fi

                          if [ -n "$acrId" ]; then
                            # Check for any role assignment for this principal on the ACR scope
                            assignCount=$(az role assignment list --assignee "$principalId" --scope "$acrId" --query "length([])" -o tsv 2>/dev/null || echo 0)
                            if [ -n "$assignCount" ] && [ "$assignCount" -gt 0 ]; then
                              echo "Found existing role assignment(s) between AKS principal ($principalId) and ACR ($acrId). Skipping attach."
                              need_attach=0
                            else
                              echo "No role assignment found between AKS principal ($principalId) and ACR ($acrId). Will attach."
                              need_attach=1
                            fi
                          else
                            # If we couldn't resolve acrId, be conservative and attach
                            need_attach=1
                          fi
                        else
                          echo "Could not determine AKS cluster principalId/servicePrincipalProfile; proceeding to attach ACR to be safe."
                          need_attach=1
                        fi

                        if [ "$need_attach" -eq 1 ]; then
                          echo "Attaching ACR '$ACR_NAME' to AKS cluster '$CLUSTER' in resource group '$RG'"
                          az aks update --resource-group "$RG" --name "$CLUSTER" --attach-acr "$ACR_NAME"
                        else
                          echo "Skipping az aks update --attach-acr because cluster already has access to ACR."
                        fi

          - task: HelmInstaller@1
            enabled: false
            displayName: Install Helm client
            inputs:
              helmVersionToInstall: "latest" # will install 4 alpha!!

          - task: PowerShell@2
            displayName: Prepare kubeconfig & ensure kubectl in PATH
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                # If a secure file downloader ran earlier it will populate DownloadKubeconfig.secureFilePath
                $secureKubeConfig = '$(DownloadKubeconfig.secureFilePath)'
                if(-not [string]::IsNullOrWhiteSpace($secureKubeConfig) -and (Test-Path $secureKubeConfig)){
                  $kubeconfigPath = Join-Path $env:AGENT_TEMPDIRECTORY 'kubeconfig'
                  Copy-Item -Path $secureKubeConfig -Destination $kubeconfigPath -Force
                  Write-Host "Copied secure-file kubeconfig to $kubeconfigPath"
                  Write-Host "##vso[task.setvariable variable=KUBECONFIG]$kubeconfigPath"
                } elseif(-not [string]::IsNullOrWhiteSpace($env:KUBECONFIG) -and (Test-Path $env:KUBECONFIG)){
                  Write-Host "KUBECONFIG already set to $env:KUBECONFIG (from previous az aks get-credentials step)"
                } else {
                  throw 'No kubeconfig available: neither DownloadSecureFile produced a kubeconfig nor was KUBECONFIG previously set. Ensure useAzureLocal=true with a secure file, or provide aksResourceGroup/aksClusterName with useAzureLocal=false.'
                }
                $kubectlCmd = Get-Command kubectl -ErrorAction SilentlyContinue
                if(-not $kubectlCmd){
                  Write-Host 'kubectl not found on PATH; downloading...'
                  $url = 'https://dl.k8s.io/release/v1.29.4/bin/linux/amd64/kubectl'
                  $kubectlPath = Join-Path $env:AGENT_TEMPDIRECTORY 'kubectl'
                  Invoke-WebRequest -Uri $url -OutFile $kubectlPath
                  chmod +x $kubectlPath
                  Write-Host "##vso[task.prependpath]$($env:AGENT_TEMPDIRECTORY)"
                  Write-Host "Downloaded kubectl to $kubectlPath and prepended AGENT_TEMPDIRECTORY to PATH"
                } else { Write-Host "kubectl found at $($kubectlCmd.Path)" }

          # Simplified: delegate pool creation, KEDA install, and Helm deployment to the repo script.
          # We keep kubeconfig preparation above; now invoke the single deploy helper with the
          # necessary parameters and environment variables.
          - task: PowerShell@2
            displayName: Assert ACR_NAME matches pipeline parameter
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $paramAcr = '${{ parameters.ACR_NAME }}'
                $envAcr = $env:ACR_NAME
                if (-not $paramAcr -or [string]::IsNullOrWhiteSpace($paramAcr)) {
                  Write-Error "Pipeline parameter ACR_NAME is empty. Ensure the pipeline passes ACR_NAME parameter."; exit 1
                }
                if (-not $envAcr -or [string]::IsNullOrWhiteSpace($envAcr)) {
                  Write-Host "Pipeline environment variable ACR_NAME is empty; setting it from pipeline parameter."
                  Write-Host "##vso[task.setvariable variable=ACR_NAME]$paramAcr"
                  Write-Host "ACR_NAME set to $paramAcr"
                }
                elseif ($envAcr -ne $paramAcr) {
                  Write-Error "ACR_NAME mismatch: pipeline parameter value='$paramAcr' but environment ACR_NAME='$envAcr'. Aborting."; exit 1
                }
                else {
                  Write-Host "ACR_NAME assertion passed: $envAcr"
                }

          - task: PowerShell@2
            displayName: Deploy agents (via repo script wrapper)
            env:
              KUBECONFIG: $(KUBECONFIG)
              ACR_NAME: ${{ parameters.ACR_NAME }}
              PIPELINE_ACR_NAME: ${{ parameters.ACR_NAME }}
              AZDO_PAT: $(AZDO_PAT)
              ACR_USERNAME: $(ACR_USERNAME)
              ACR_PASSWORD: $(ACR_PASSWORD)
              INSTANCE_NUMBER: "${{ parameters.instanceNumber }}"
              DEPLOY_LINUX: $(DEPLOY_LINUX)
              DEPLOY_WINDOWS: "${{ parameters.deployWindows }}"
              AZDO_ORG_URL: "${{ parameters.azureDevOpsOrgUrl }}"
            inputs:
              targetType: filePath
              # Use POSIX-style forward slashes so the path resolves correctly on linux agents
              filePath: "$(Build.SourcesDirectory)/.azuredevops/scripts/run-deploy-selfhosted-agents-helm.ps1"
              pwsh: true

          - task: PowerShell@2
            displayName: Compute DEPLOY_LINUX variable
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $deployLinuxParam = [System.Convert]::ToBoolean('${{ parameters.deployLinux }}')
                $skipLinuxParam = [System.Convert]::ToBoolean('${{ parameters.skipLinux }}')
                $deployLinux = ($deployLinuxParam -and -not $skipLinuxParam)
                Write-Host "Computed deployLinux (deployLinuxParam=$deployLinuxParam, skipLinuxParam=$skipLinuxParam) => $deployLinux"
                Write-Host "##vso[task.setvariable variable=DEPLOY_LINUX]$deployLinux"

          - task: PowerShell@2
            name: SetHelmOutputs
            displayName: Set Helm release outputs (for Summary job)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $instance = '${{ parameters.instanceNumber }}'
                if([string]::IsNullOrWhiteSpace($instance)){ $instance = '003' }
                $releaseName = "az-selfhosted-agents-$instance"
                # determine namespace selection same as the repo script
                $deployLinuxRaw = '${{ parameters.deployLinux }}'
                $deployWindowsRaw = '${{ parameters.deployWindows }}'
                $deployLinux = $false; if($deployLinuxRaw -match '^[Tt]rue$|^1$'){ $deployLinux = $true }
                $deployWindows = $false; if($deployWindowsRaw -match '^[Tt]rue$|^1$'){ $deployWindows = $true }
                $releaseNamespace = if($deployLinux){ "az-devops-linux-$instance" } elseif($deployWindows){ "az-devops-windows-$instance" } else { "az-devops-linux-$instance" }
                Write-Host "##vso[task.setvariable variable=HELM_RELEASE_NAME;isOutput=true]$releaseName"
                Write-Host "##vso[task.setvariable variable=HELM_RELEASE_NAMESPACE;isOutput=true]$releaseNamespace"

          - task: PublishPipelineArtifact@1
            displayName: Publish helm values override
            inputs:
              targetPath: "$(Build.ArtifactStagingDirectory)/helm-values-override.yaml"
              artifact: helm-values

          - task: PowerShell@2
            displayName: Post-deploy verification
            env:
              KUBECONFIG: $(KUBECONFIG)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                Write-Host 'KEDA pods:'
                try { kubectl get pods -n keda -o wide } catch { Write-Warning "Failed to list KEDA pods: $($_.Exception.Message)" }
                $inst = '${{ parameters.instanceNumber }}'; if([string]::IsNullOrWhiteSpace($inst)){ $inst='003' }
                $linuxNs = "az-devops-linux-$inst"
                $winNs = "az-devops-windows-$inst"
                Write-Host "Note: az-devops-$inst is deprecated; showing per-OS namespaces instead."
                Write-Host "Deployments in ${linuxNs} (if present):"
                try { kubectl get deployment -n ${linuxNs} -o wide } catch { Write-Host "No resources found in ${linuxNs} or namespace missing." }
                Write-Host "Deployments in ${winNs} (if present):"
                try { kubectl get deployment -n ${winNs} -o wide } catch { Write-Host "No resources found in ${winNs} or namespace missing." }

      - job: Summary
        displayName: Summary
        dependsOn: HelmDeploy
        condition: succeededOrFailed()
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        steps:
          - task: PowerShell@2
            displayName: Generate config artifact (for validation pipeline)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $config = [ordered]@{
                  instanceNumber    = '${{ parameters.instanceNumber }}'
                  deployLinux       = $${{ parameters.deployLinux }}
                  deployWindows     = $${{ parameters.deployWindows }}
                  azureDevOpsOrgUrl = '${{ parameters.azureDevOpsOrgUrl }}'
                  windowsVersion    = '${{ parameters.windowsVersion }}'
                  linuxImageVariant = '${{ parameters.linuxImageVariant }}'
                  useAzureLocal     = $${{ parameters.useAzureLocal }}
                } | ConvertTo-Json -Depth 5
                $path = Join-Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY 'config.json'
                $config | Out-File $path -Encoding utf8
                Write-Host "Wrote config to $path"
          - task: PublishPipelineArtifact@1
            displayName: Publish agent config artifact
            inputs:
              targetPath: "$(Build.ArtifactStagingDirectory)/config.json"
              artifact: agent-config
              publishLocation: pipeline
          - task: PowerShell@2
            displayName: Compute & attach resource name summary
            env:
              # runtime expression: inject the HelmDeploy job result into the task environment
              HELM_DEPLOY_RESULT: $[ dependencies.HelmDeploy.result ]
              # Read outputs from the HelmDeploy.SetHelmOutputs task (job-scoped output variables)
              HELM_RELEASE_NAME: $[ dependencies.HelmDeploy.outputs['SetHelmOutputs.HELM_RELEASE_NAME'] ]
              HELM_RELEASE_NAMESPACE: $[ dependencies.HelmDeploy.outputs['SetHelmOutputs.HELM_RELEASE_NAMESPACE'] ]
            inputs:
              targetType: inline
              pwsh: true
              script: |
                # Defensive summary: don't let unexpanded runtime tokens or missing helm/commands fail the task
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Continue'
                try {
                  $instance = '${{ parameters.instanceNumber }}'
                  if([string]::IsNullOrWhiteSpace($instance)){ $instance = '003' }
                  $useLocalParam = $false
                  try { $useLocalParam = [bool]('${{ parameters.useAzureLocal }}') } catch { $useLocalParam = $false }
                  if ($useLocalParam) { $linuxPool = "KubernetesPoolOnPremLinux$instance"; $windowsPool = "KubernetesPoolOnPremWindows$instance" } else { $linuxPool = "KubernetesPoolLinux$instance"; $windowsPool = "KubernetesPoolWindows$instance" }
                  $linuxNamespace   = "az-devops-linux-$instance"
                  $windowsNamespace = "az-devops-windows-$instance"
                  $linuxSecret      = "linux-sh-agent-secret-$instance"
                  $linuxDeployment  = "linux-sh-agent-deployment-$instance"
                  $windowsSecret    = "windows-sh-agent-secret-$instance"
                  $windowsDeployment= "windows-sh-agent-deployment-$instance"

                  # Read the injected helm deploy result from the environment (may be an unexpanded runtime token)
                  $linuxResult = $env:HELM_DEPLOY_RESULT
                  if([string]::IsNullOrWhiteSpace($linuxResult)){
                    $linuxResult = 'Unknown'
                  }
                  # If runtime-expression tokens were passed verbatim (e.g. $[ dependencies... ]) replace with Unknown
                  if($linuxResult.Trim().StartsWith('$[')){
                    $linuxResult = 'Unknown'
                  }

                  $releaseName = $env:HELM_RELEASE_NAME
                  $releaseNamespace = $env:HELM_RELEASE_NAMESPACE
                  if([string]::IsNullOrWhiteSpace($releaseName) -or $releaseName.Trim().StartsWith('$[')){ $releaseName = 'az-selfhosted-agents' }
                  if([string]::IsNullOrWhiteSpace($releaseNamespace) -or $releaseNamespace.Trim().StartsWith('$[')){ $releaseNamespace = "az-devops-linux-$instance" }

                  $lines = @(
                    '# Self-hosted Agents Deployment Resources',
                    '',
                    "**Instance Number:** $instance",
                    '',
                    '## Resource Names',
                    '| Resource Type | Linux | Windows |',
                    '|---------------|-------|---------|',
                    "| Namespace | $linuxNamespace | $windowsNamespace |",
                    "| Pool | $linuxPool | $windowsPool |",
                    "| Secret | $linuxSecret | $windowsSecret |",
                    "| Deployment | $linuxDeployment | $windowsDeployment |",
                    '',
                    '## Job Results',
                    "* Linux Job Result: $linuxResult",
                    '',
                    '## Notes',
                    '- Resource names are derived; if a platform was skipped its Kubernetes objects may not exist yet.',
                    "- Adjust instanceNumber parameter to provision another isolated set."
                  )

                  $outPath = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'resource-summary.md'
                  $lines | Out-File $outPath -Encoding utf8
                  Write-Host "Summary markdown written to $outPath"
                  Write-Host "##vso[task.addattachment type=Distributedtask.Core.Summary;name=Deployment Resources]$outPath"
                  $lines | ForEach-Object { Write-Host $_ }

                  # If helm is available try to fetch the applied values for the release and attach them as an extra artifact
                  $helm = Get-Command helm -ErrorAction SilentlyContinue
                  if($helm){
                    try{
                      $values = & helm get values $releaseName -n $releaseNamespace -o yaml 2>$null
                      if(-not [string]::IsNullOrWhiteSpace($values)){
                        # Local helper to mask obvious secrets before writing to artifacts
                        function MaskSensitive([string]$text){
                          if(-not $text){ return $text }
                          $opts = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase -bor [System.Text.RegularExpressions.RegexOptions]::Multiline
                          # AZP tokens
                          $text = [regex]::Replace($text, '(?mi)^(\s*(?:AZP_TOKEN|AZP_TOKEN_VALUE)\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          # personalAccessToken
                          $text = [regex]::Replace($text, '(?mi)^(\s*personalAccessToken\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          # dockerconfigjson inline fields
                          $text = [regex]::Replace($text, '(?mi)("password"\s*:\s*")([^"]+)(")', '${1}(redacted)${3}', $opts)
                          $text = [regex]::Replace($text, '(?mi)("auth"\s*:\s*")([^"]+)(")', '${1}(redacted)${3}', $opts)
                          # generic password keys
                          $text = [regex]::Replace($text, '(?mi)^(\s*password\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          return $text
                        }
                        $valsPath = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'helm-applied-values.yaml'
                        $masked = MaskSensitive $values
                        $masked | Out-File $valsPath -Encoding utf8
                        Write-Host "Wrote masked helm applied values to $valsPath"
                        Write-Host "##vso[task.uploadfile]$valsPath"
                      }
                    } catch { Write-Host "helm get values failed: $($_.Exception.Message)" }
                  } else { Write-Host 'helm client not found in PATH; skipping helm get values.' }
                } catch {
                  Write-Host "Summary step encountered non-fatal error: $($_.Exception.Message)"
                } finally {
                  # Ensure this summary step never fails the pipeline
                  exit 0
                }

          - task: PowerShell@2
            displayName: Check for applied helm values file
            name: CheckHelmAppliedValues
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $path = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'helm-applied-values.yaml'
                if(Test-Path $path){
                  Write-Host "Found applied helm values at $path"
                  Write-Host "##vso[task.setvariable variable=HelmAppliedValuesExists]true"
                } else {
                  Write-Host "Applied helm values not found at $path"
                  Write-Host "##vso[task.setvariable variable=HelmAppliedValuesExists]false"
                }

          - task: PublishPipelineArtifact@1
            displayName: Publish applied helm values (if present)
            inputs:
              targetPath: "$(System.DefaultWorkingDirectory)/helm-applied-values.yaml"
              artifact: helm-applied-values
            condition: and(succeeded(), eq(variables['HelmAppliedValuesExists'], 'true'))
