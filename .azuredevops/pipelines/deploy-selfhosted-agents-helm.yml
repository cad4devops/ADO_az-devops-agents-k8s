# Deploy self-hosted agents using Helm (ensures KEDA is installed)
trigger: none
pr: none

parameters:
  - name: deployLinux
    type: boolean
    default: true
  - name: deployWindows
    type: boolean
    default: true
  - name: windowsVersion
    type: string
    default: '2022'
  - name: linuxImageVariant
    type: string
    default: 'docker'
  - name: acrName
    type: string
    default: 'cragentssgvhe4aipy37o'
  - name: azureDevOpsOrgUrl
    type: string
    default: 'https://dev.azure.com/cad4devops'
  - name: instanceNumber
    type: string
    default: '003'
  - name: bootstrapPoolName
    type: string
    default: 'KubernetesPoolWindows'

variables:
  - group: ADO_az-devops-agents-k8s
  - name: azureSubscription
    value: ADO_SvcConnRgScopedProd

stages:
  - stage: DeployHelm
    displayName: Deploy via Helm (install KEDA)
    jobs:
      - job: HelmDeploy
        displayName: Deploy agents Helm chart
        pool:
          ${{ if ne(parameters.bootstrapPoolName, '') }}:
            name: ${{ parameters.bootstrapPoolName }}
          ${{ if eq(parameters.bootstrapPoolName, '') }}:
            vmImage: ubuntu-latest
        steps:
          - checkout: self

          - task: DownloadSecureFile@1
            name: DownloadKubeconfig
            displayName: Download AKS kubeconfig (secure file)
            inputs:
              secureFile: AKS_my-workload-cluster-dev-014-kubeconfig_file

          - task: HelmInstaller@1
            enabled: false
            displayName: Install Helm client
            inputs:
              helmVersionToInstall: 'latest' # will install 4 alpha!!

          - task: PowerShell@2
            displayName: Prepare kubeconfig & ensure kubectl in PATH
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $secureKubeConfig = '$(DownloadKubeconfig.secureFilePath)'
                if(-not $secureKubeConfig){ throw 'DownloadSecureFile did not produce a path. Ensure the task name is DownloadKubeconfig.' }
                $kubeconfigPath = Join-Path $env:AGENT_TEMPDIRECTORY 'kubeconfig'
                Copy-Item -Path $secureKubeConfig -Destination $kubeconfigPath -Force
                Write-Host "Copied kubeconfig to $kubeconfigPath"
                Write-Host "##vso[task.setvariable variable=KUBECONFIG]$kubeconfigPath"
                $kubectlCmd = Get-Command kubectl -ErrorAction SilentlyContinue
                if(-not $kubectlCmd){
                  Write-Host 'kubectl not found on PATH; downloading...'
                  $url = 'https://dl.k8s.io/release/v1.29.4/bin/linux/amd64/kubectl'
                  $kubectlPath = Join-Path $env:AGENT_TEMPDIRECTORY 'kubectl'
                  Invoke-WebRequest -Uri $url -OutFile $kubectlPath
                  chmod +x $kubectlPath
                  Write-Host "##vso[task.prependpath]$($env:AGENT_TEMPDIRECTORY)"
                  Write-Host "Downloaded kubectl to $kubectlPath and prepended AGENT_TEMPDIRECTORY to PATH"
                } else { Write-Host "kubectl found at $($kubectlCmd.Path)" }

          # Simplified: delegate pool creation, KEDA install, and Helm deployment to the repo script.
          # We keep kubeconfig preparation above; now invoke the single deploy helper with the
          # necessary parameters and environment variables.
          - task: PowerShell@2
            displayName: Deploy agents (via repo script wrapper)
            env:
              KUBECONFIG: $(KUBECONFIG)
              ACR_NAME: ${{ parameters.acrName }}
              AZDO_PAT: $(AZDO_PAT)
              ACR_USERNAME: $(ACR_USERNAME)
              ACR_PASSWORD: $(ACR_PASSWORD)
              INSTANCE_NUMBER: '${{ parameters.instanceNumber }}'
              DEPLOY_LINUX: '${{ parameters.deployLinux }}'
              DEPLOY_WINDOWS: '${{ parameters.deployWindows }}'
              AZDO_ORG_URL: '${{ parameters.azureDevOpsOrgUrl }}'
            inputs:
              targetType: filePath
              filePath: '$(Build.SourcesDirectory)\\.azuredevops\\scripts\\run-deploy-selfhosted-agents-helm.ps1'
              pwsh: true

          - task: PowerShell@2
            name: SetHelmOutputs
            displayName: Set Helm release outputs (for Summary job)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $instance = '${{ parameters.instanceNumber }}'
                if([string]::IsNullOrWhiteSpace($instance)){ $instance = '003' }
                $releaseName = "az-selfhosted-agents-$instance"
                # determine namespace selection same as the repo script
                $deployLinuxRaw = '${{ parameters.deployLinux }}'
                $deployWindowsRaw = '${{ parameters.deployWindows }}'
                $deployLinux = $false; if($deployLinuxRaw -match '^[Tt]rue$|^1$'){ $deployLinux = $true }
                $deployWindows = $false; if($deployWindowsRaw -match '^[Tt]rue$|^1$'){ $deployWindows = $true }
                $releaseNamespace = if($deployLinux){ "az-devops-linux-$instance" } elseif($deployWindows){ "az-devops-windows-$instance" } else { "az-devops-linux-$instance" }
                Write-Host "##vso[task.setvariable variable=HELM_RELEASE_NAME;isOutput=true]$releaseName"
                Write-Host "##vso[task.setvariable variable=HELM_RELEASE_NAMESPACE;isOutput=true]$releaseNamespace"

          - task: PublishPipelineArtifact@1
            displayName: Publish helm values override
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/helm-values-override.yaml'
              artifact: helm-values

          - task: PowerShell@2
            displayName: Post-deploy verification
            env:
              KUBECONFIG: $(KUBECONFIG)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                Write-Host 'KEDA pods:'
                try { kubectl get pods -n keda -o wide } catch { Write-Warning "Failed to list KEDA pods: $($_.Exception.Message)" }
                $inst = '${{ parameters.instanceNumber }}'; if([string]::IsNullOrWhiteSpace($inst)){ $inst='003' }
                $linuxNs = "az-devops-linux-$inst"
                $winNs = "az-devops-windows-$inst"
                Write-Host "Note: az-devops-$inst is deprecated; showing per-OS namespaces instead."
                Write-Host "Deployments in ${linuxNs} (if present):"
                try { kubectl get deployment -n ${linuxNs} -o wide } catch { Write-Host "No resources found in ${linuxNs} or namespace missing." }
                Write-Host "Deployments in ${winNs} (if present):"
                try { kubectl get deployment -n ${winNs} -o wide } catch { Write-Host "No resources found in ${winNs} or namespace missing." }

      - job: Summary
        displayName: Summary
        dependsOn: HelmDeploy
        condition: succeededOrFailed()
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: PowerShell@2
            displayName: Generate config artifact (for validation pipeline)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $config = [ordered]@{
                  instanceNumber    = '${{ parameters.instanceNumber }}'
                  deployLinux       = $${{ parameters.deployLinux }}
                  deployWindows     = $${{ parameters.deployWindows }}
                  azureDevOpsOrgUrl = '${{ parameters.azureDevOpsOrgUrl }}'
                  windowsVersion    = '${{ parameters.windowsVersion }}'
                  linuxImageVariant = '${{ parameters.linuxImageVariant }}'
                } | ConvertTo-Json -Depth 5
                $path = Join-Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY 'config.json'
                $config | Out-File $path -Encoding utf8
                Write-Host "Wrote config to $path"
          - task: PublishPipelineArtifact@1
            displayName: Publish agent config artifact
            inputs:
              targetPath: "$(Build.ArtifactStagingDirectory)/config.json"
              artifact: agent-config
              publishLocation: pipeline
          - task: PowerShell@2
            displayName: Compute & attach resource name summary
            env:
              # runtime expression: inject the HelmDeploy job result into the task environment
              HELM_DEPLOY_RESULT: $[ dependencies.HelmDeploy.result ]
              # Read outputs from the HelmDeploy.SetHelmOutputs task (job-scoped output variables)
              HELM_RELEASE_NAME: $[ dependencies.HelmDeploy.outputs['SetHelmOutputs.HELM_RELEASE_NAME'] ]
              HELM_RELEASE_NAMESPACE: $[ dependencies.HelmDeploy.outputs['SetHelmOutputs.HELM_RELEASE_NAMESPACE'] ]
            inputs:
              targetType: inline
              pwsh: true
              script: |
                # Defensive summary: don't let unexpanded runtime tokens or missing helm/commands fail the task
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Continue'
                try {
                  $instance = '${{ parameters.instanceNumber }}'
                  if([string]::IsNullOrWhiteSpace($instance)){ $instance = '003' }
                  $linuxPool        = "KubernetesPoolLinux$instance"
                  $windowsPool      = "KubernetesPoolWindows$instance"
                  $linuxNamespace   = "az-devops-linux-$instance"
                  $windowsNamespace = "az-devops-windows-$instance"
                  $linuxSecret      = "linux-sh-agent-secret-$instance"
                  $linuxDeployment  = "linux-sh-agent-deployment-$instance"
                  $windowsSecret    = "windows-sh-agent-secret-$instance"
                  $windowsDeployment= "windows-sh-agent-deployment-$instance"

                  # Read the injected helm deploy result from the environment (may be an unexpanded runtime token)
                  $linuxResult = $env:HELM_DEPLOY_RESULT
                  if([string]::IsNullOrWhiteSpace($linuxResult)){
                    $linuxResult = 'Unknown'
                  }
                  # If runtime-expression tokens were passed verbatim (e.g. $[ dependencies... ]) replace with Unknown
                  if($linuxResult.Trim().StartsWith('$[')){
                    $linuxResult = 'Unknown'
                  }

                  $releaseName = $env:HELM_RELEASE_NAME
                  $releaseNamespace = $env:HELM_RELEASE_NAMESPACE
                  if([string]::IsNullOrWhiteSpace($releaseName) -or $releaseName.Trim().StartsWith('$[')){ $releaseName = 'az-selfhosted-agents' }
                  if([string]::IsNullOrWhiteSpace($releaseNamespace) -or $releaseNamespace.Trim().StartsWith('$[')){ $releaseNamespace = "az-devops-linux-$instance" }

                  $lines = @(
                    '# Self-hosted Agents Deployment Resources',
                    '',
                    "**Instance Number:** $instance",
                    '',
                    '## Resource Names',
                    '| Resource Type | Linux | Windows |',
                    '|---------------|-------|---------|',
                    "| Namespace | $linuxNamespace | $windowsNamespace |",
                    "| Pool | $linuxPool | $windowsPool |",
                    "| Secret | $linuxSecret | $windowsSecret |",
                    "| Deployment | $linuxDeployment | $windowsDeployment |",
                    '',
                    '## Job Results',
                    "* Linux Job Result: $linuxResult",
                    '',
                    '## Notes',
                    '- Resource names are derived; if a platform was skipped its Kubernetes objects may not exist yet.',
                    "- Adjust instanceNumber parameter to provision another isolated set."
                  )

                  $outPath = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'resource-summary.md'
                  $lines | Out-File $outPath -Encoding utf8
                  Write-Host "Summary markdown written to $outPath"
                  Write-Host "##vso[task.addattachment type=Distributedtask.Core.Summary;name=Deployment Resources]$outPath"
                  $lines | ForEach-Object { Write-Host $_ }

                  # If helm is available try to fetch the applied values for the release and attach them as an extra artifact
                  $helm = Get-Command helm -ErrorAction SilentlyContinue
                  if($helm){
                    try{
                      $values = & helm get values $releaseName -n $releaseNamespace -o yaml 2>$null
                      if(-not [string]::IsNullOrWhiteSpace($values)){
                        # Local helper to mask obvious secrets before writing to artifacts
                        function MaskSensitive([string]$text){
                          if(-not $text){ return $text }
                          $opts = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase -bor [System.Text.RegularExpressions.RegexOptions]::Multiline
                          # AZP tokens
                          $text = [regex]::Replace($text, '(?mi)^(\s*(?:AZP_TOKEN|AZP_TOKEN_VALUE)\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          # personalAccessToken
                          $text = [regex]::Replace($text, '(?mi)^(\s*personalAccessToken\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          # dockerconfigjson inline fields
                          $text = [regex]::Replace($text, '(?mi)("password"\s*:\s*")([^"]+)(")', '${1}(redacted)${3}', $opts)
                          $text = [regex]::Replace($text, '(?mi)("auth"\s*:\s*")([^"]+)(")', '${1}(redacted)${3}', $opts)
                          # generic password keys
                          $text = [regex]::Replace($text, '(?mi)^(\s*password\s*:\s*)(?:''[^'']*''|"[^"]*"|[^\r\n]+)', '${1}(redacted)', $opts)
                          return $text
                        }
                        $valsPath = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'helm-applied-values.yaml'
                        $masked = MaskSensitive $values
                        $masked | Out-File $valsPath -Encoding utf8
                        Write-Host "Wrote masked helm applied values to $valsPath"
                        Write-Host "##vso[task.uploadfile]$valsPath"
                      }
                    } catch { Write-Host "helm get values failed: $($_.Exception.Message)" }
                  } else { Write-Host 'helm client not found in PATH; skipping helm get values.' }
                } catch {
                  Write-Host "Summary step encountered non-fatal error: $($_.Exception.Message)"
                } finally {
                  # Ensure this summary step never fails the pipeline
                  exit 0
                }

          - task: PowerShell@2
            displayName: Check for applied helm values file
            name: CheckHelmAppliedValues
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $path = Join-Path "$env:SYSTEM_DEFAULTWORKINGDIRECTORY" 'helm-applied-values.yaml'
                if(Test-Path $path){
                  Write-Host "Found applied helm values at $path"
                  Write-Host "##vso[task.setvariable variable=HelmAppliedValuesExists]true"
                } else {
                  Write-Host "Applied helm values not found at $path"
                  Write-Host "##vso[task.setvariable variable=HelmAppliedValuesExists]false"
                }

          - task: PublishPipelineArtifact@1
            displayName: Publish applied helm values (if present)
            inputs:
              targetPath: '$(System.DefaultWorkingDirectory)/helm-applied-values.yaml'
              artifact: helm-applied-values
            condition: and(succeeded(), eq(variables['HelmAppliedValuesExists'], 'true'))
