# Separate pipeline to validate newly deployed self-hosted agents
# This pipeline is triggered by the completion of the deploy-selfhosted-agents pipeline as a pipeline resource.
# It downloads the 'agent-config' artifact (config.json) and uses its values to know which pools to validate.

# Short description: Validate that deployed self-hosted agent pools (Linux/Windows) come online and
# trigger a small sample pipeline on each pool to confirm agents can run jobs. Set the
# `useOnPremAgents` parameter to true to run the validation jobs on an on-prem agent pool
# named 'UbuntuLatestPoolOnPrem' instead of using the hosted `ubuntu-latest` pool.

trigger: none
pr: none

parameters:
  - name: linuxHelloWaitSeconds
    type: number
    default: 120
  - name: windowsHelloWaitSeconds
    type: number
    default: 180
  - name: useOnPremAgents
    type: boolean
    default: false # Set to true to use on-premises agents, false to use cloud agents

resources:
  pipelines:
    - pipeline: deployAgentsHelm
      source: ADO_az-devops-agents-k8s-deploy-self-hosted-agents-helm
      trigger: true # automatic trigger on successful run of source pipeline

variables:
  - group: ADO_az-devops-agents-k8s
  - name: samplePipelineNameHelm
    value: ADO_az-devops-agents-k8s-run-on-selfhosted-pool-sample-helm # changed to helm pipeline name

stages:
  - stage: Validate
    displayName: Validate self-hosted agent pools
    jobs:
      - job: LoadConfig
        displayName: Load configuration artifact
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        steps:
          - download: deployAgentsHelm
            artifact: agent-config
          - task: PowerShell@2
            name: ParseConfig
            displayName: Parse config.json
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $path = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                if(-not (Test-Path $path)){ throw "Config file not found at $path" }
                $cfg = Get-Content $path -Raw | ConvertFrom-Json
                Write-Host "Loaded config:" ($cfg | ConvertTo-Json -Compress)
                # Export as job output variables so downstream jobs can reference them
                Write-Host "##vso[task.setvariable variable=instanceNumber;isOutput=true]$($cfg.instanceNumber)"
                Write-Host "##vso[task.setvariable variable=deployLinux;isOutput=true]$($cfg.deployLinux)"
                Write-Host "##vso[task.setvariable variable=deployWindows;isOutput=true]$($cfg.deployWindows)"
                Write-Host "##vso[task.setvariable variable=azureDevOpsOrgUrl;isOutput=true]$($cfg.azureDevOpsOrgUrl)"
      - job: ValidateLinux
        displayName: Validate Linux self-hosted pool
        dependsOn: LoadConfig
        condition: eq(dependencies.LoadConfig.outputs['ParseConfig.deployLinux'], 'True')
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          - name: instanceNumber
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.instanceNumber'] ]
          - name: azureDevOpsOrgUrl
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.azureDevOpsOrgUrl'] ]
          - name: linuxHelloWaitSeconds
            value: ${{ parameters.linuxHelloWaitSeconds }}
        steps:
          - download: deployAgentsHelm
            artifact: agent-config
          - task: PowerShell@2
            displayName: Poll Linux pool
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                $instance = '$(instanceNumber)'
                $orgUrl = '$(azureDevOpsOrgUrl)'
                $poolName = "KubernetesPoolLinux$instance"
                $authHeader = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(':' + $pat))
                $headers = @{ Authorization = $authHeader }
                $apiVersion = '7.1-preview.1'
                $maxSeconds = 600
                $interval = 10
                $elapsed = 0
                Write-Host "Waiting for Linux agent in pool $poolName"
                while($true){
                  $poolResp = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools?poolName=$([Uri]::EscapeDataString($poolName))&api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                  if($poolResp.count -gt 0){
                    $poolId = $poolResp.value[0].id
                    $agents = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools/$poolId/agents?api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                    $online = @($agents.value | Where-Object { $_.status -eq 'online' })
                    if($online.Count -gt 0){ Write-Host "Linux agent online: $($online[0].name)"; break }
                  }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for Linux agent" }
                  Start-Sleep -Seconds $interval; $elapsed += $interval; Write-Host "...still waiting ($elapsed s)";
                }
          - task: PowerShell@2
            name: TriggerSample
            displayName: Trigger sample pipeline on self-hosted Linux pool
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                if(-not (Test-Path $cfgPath)){ throw "Config artifact not found at $cfgPath" }
                $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                $instance = $cfg.instanceNumber
                $orgUrl = $cfg.azureDevOpsOrgUrl
                $project = $env:SYSTEM_TEAMPROJECT

                $pipelineName = '$(samplePipelineNameHelm)'
                Write-Host "Triggering sample pipeline '$pipelineName' for instance $instance (os=linux)"

                $null = & az --version 2>$null
                if($LASTEXITCODE -ne 0){ throw 'Azure CLI (az) not found on PATH; unable to trigger pipeline via az CLI' }
                $ext = (& az extension list --query "[?name=='azure-devops']" -o json) | ConvertFrom-Json
                if(-not $ext){ Write-Host 'Installing azure-devops extension'; az extension add --name azure-devops --yes | Out-Null }

                $env:AZURE_DEVOPS_EXT_PAT = $pat
                & az devops configure --defaults organization=$orgUrl project=$project | Out-Null

                $runJson = & az pipelines run --name $pipelineName --parameters instanceNumber=$instance os=linux helloWaitSeconds=$(linuxHelloWaitSeconds) --output json 2>&1
                if($LASTEXITCODE -ne 0){ Write-Error $runJson; throw 'Failed to queue sample pipeline run via az pipelines run' }
                $runObj = $runJson | Out-String | ConvertFrom-Json
                $runId = $runObj.id
                if(-not $runId){ throw 'Could not determine run id from az pipelines run output' }
                Write-Host "Queued pipeline run id: $runId"
                Write-Host "##vso[task.setvariable variable=sampleRunId;isOutput=true]$runId"
                $runUrl = "$orgUrl/$project/_build/results?buildId=$runId&view=results"
                Write-Host "##vso[task.setvariable variable=sampleRunUrl;isOutput=true]$runUrl"

                $state = $null; $result = $null
                $maxSeconds = 1800
                $interval = 5
                $elapsed = 0
                Write-Host "Sample run URL: $runUrl"
                while($true){
                  Start-Sleep -Seconds $interval
                  $elapsed += $interval
                  $showRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                  try{ $showObj = $showRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse az pipelines runs show output: $showRaw"; if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to produce valid status after $maxSeconds seconds (runId=$runId)" }; continue }
                  if($null -eq $showObj){ Write-Host 'No run information yet'; if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to start after $maxSeconds seconds (runId=$runId)" }; continue }
                  $info = if($showObj -is [System.Array]){ $showObj[0] } else { $showObj }
                  if($info.PSObject.Properties.Name -contains 'state'){ $state = $info.state } elseif($info.PSObject.Properties.Name -contains 'status'){ $state = $info.status }
                  if($info.PSObject.Properties.Name -contains 'result'){ $result = $info.result }
                  Write-Host "Sample run state=$state result=$result (elapsed=${elapsed}s)"
                  if($state -in @('completed','canceled','failed')){ break }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to complete after $maxSeconds seconds (runId=$runId). Last known state='$state' result='$result'" }
                }
                $finalRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                $finalObj = $null
                try{ $finalObj = $finalRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse final run show output: $finalRaw" }
                $finalInfo = if($finalObj -is [System.Array]){ $finalObj[0] } else { $finalObj }
                $finalResult = $null
                if($finalInfo -ne $null -and $finalInfo.PSObject.Properties.Name -contains 'result'){ $finalResult = $finalInfo.result }
                if(-not $finalResult){ $finalResult = $result }
                if($finalResult -ne 'succeeded'){
                  Write-Host 'Sample pipeline final run JSON (raw):'
                  Write-Host $finalRaw
                  Write-Host 'Sample pipeline final run object:'
                  if($finalObj){ $finalObj | ConvertTo-Json -Depth 5 | Write-Host } else { Write-Host '<could not parse final JSON>' }
                  throw "Sample pipeline run did not succeed (result=$finalResult)"
                }
      - job: ValidateWindows
        displayName: Validate Windows self-hosted pool
        dependsOn: LoadConfig
        condition: eq(dependencies.LoadConfig.outputs['ParseConfig.deployWindows'], 'True')
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          - name: instanceNumber
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.instanceNumber'] ]
          - name: azureDevOpsOrgUrl
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.azureDevOpsOrgUrl'] ]
          - name: windowsHelloWaitSeconds
            value: ${{ parameters.windowsHelloWaitSeconds }}
        steps:
          - download: deployAgentsHelm
            artifact: agent-config
          - task: PowerShell@2
            displayName: Poll Windows pool
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                $instance = '$(instanceNumber)'
                $orgUrl = '$(azureDevOpsOrgUrl)'
                $poolName = "KubernetesPoolWindows$instance"
                $authHeader = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(':' + $pat))
                $headers = @{ Authorization = $authHeader }
                $apiVersion = '7.1-preview.1'
                $maxSeconds = 900
                $interval = 15
                $elapsed = 0
                Write-Host "Waiting for Windows agent in pool $poolName"
                while($true){
                  $poolResp = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools?poolName=$([Uri]::EscapeDataString($poolName))&api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                  if($poolResp.count -gt 0){
                    $poolId = $poolResp.value[0].id
                    $agents = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools/$poolId/agents?api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                    $online = @($agents.value | Where-Object { $_.status -eq 'online' })
                    if($online.Count -gt 0){ Write-Host "Windows agent online: $($online[0].name)"; break }
                  }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for Windows agent" }
                  Start-Sleep -Seconds $interval; $elapsed += $interval; Write-Host "...still waiting ($elapsed s)";
                }
          - task: PowerShell@2
            name: TriggerSample
            displayName: Trigger sample pipeline on self-hosted Windows pool
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                if(-not (Test-Path $cfgPath)){ throw "Config artifact not found at $cfgPath" }
                $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                $instance = $cfg.instanceNumber
                $orgUrl = $cfg.azureDevOpsOrgUrl
                $project = $env:SYSTEM_TEAMPROJECT

                $pipelineName = '$(samplePipelineNameHelm)'
                Write-Host "Triggering sample pipeline '$pipelineName' for instance $instance (os=windows)"

                $null = & az --version 2>$null
                if($LASTEXITCODE -ne 0){ throw 'Azure CLI (az) not found on PATH; unable to trigger pipeline via az CLI' }
                $ext = (& az extension list --query "[?name=='azure-devops']" -o json) | ConvertFrom-Json
                if(-not $ext){ Write-Host 'Installing azure-devops extension'; az extension add --name azure-devops --yes | Out-Null }

                $env:AZURE_DEVOPS_EXT_PAT = $pat
                & az devops configure --defaults organization=$orgUrl project=$project | Out-Null

                $runJson = & az pipelines run --name $pipelineName --parameters instanceNumber=$instance os=windows helloWaitSeconds=$(windowsHelloWaitSeconds) --output json 2>&1
                if($LASTEXITCODE -ne 0){ Write-Error $runJson; throw 'Failed to queue sample pipeline run via az pipelines run' }
                $runObj = $runJson | Out-String | ConvertFrom-Json
                $runId = $runObj.id
                if(-not $runId){ throw 'Could not determine run id from az pipelines run output' }
                Write-Host "Queued pipeline run id: $runId"
                Write-Host "##vso[task.setvariable variable=sampleRunId;isOutput=true]$runId"
                $runUrl = "$orgUrl/$project/_build/results?buildId=$runId&view=results"
                Write-Host "##vso[task.setvariable variable=sampleRunUrl;isOutput=true]$runUrl"

                $state = $null; $result = $null
                $maxSeconds = 1800
                $interval = 5
                $elapsed = 0
                Write-Host "Sample run URL: $runUrl"
                while($true){
                  Start-Sleep -Seconds $interval
                  $elapsed += $interval
                  $showRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                  try{ $showObj = $showRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse az pipelines runs show output: $showRaw"; if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to produce valid status after $maxSeconds seconds (runId=$runId)" }; continue }
                  if($null -eq $showObj){ Write-Host 'No run information yet'; if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to start after $maxSeconds seconds (runId=$runId)" }; continue }
                  $info = if($showObj -is [System.Array]){ $showObj[0] } else { $showObj }
                  if($info.PSObject.Properties.Name -contains 'state'){ $state = $info.state } elseif($info.PSObject.Properties.Name -contains 'status'){ $state = $info.status }
                  if($info.PSObject.Properties.Name -contains 'result'){ $result = $info.result }
                  Write-Host "Sample run state=$state result=$result (elapsed=${elapsed}s)"
                  if($state -in @('completed','canceled','failed')){ break }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to complete after $maxSeconds seconds (runId=$runId). Last known state='$state' result='$result'" }
                }
                $finalRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                $finalObj = $null
                try{ $finalObj = $finalRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse final run show output: $finalRaw" }
                $finalInfo = if($finalObj -is [System.Array]){ $finalObj[0] } else { $finalObj }
                $finalResult = $null
                if($finalInfo -ne $null -and $finalInfo.PSObject.Properties.Name -contains 'result'){ $finalResult = $finalInfo.result }
                if(-not $finalResult){ $finalResult = $result }
                if($finalResult -ne 'succeeded'){
                  Write-Host 'Sample pipeline final run JSON (raw):'
                  Write-Host $finalRaw
                  Write-Host 'Sample pipeline final run object:'
                  if($finalObj){ $finalObj | ConvertTo-Json -Depth 5 | Write-Host } else { Write-Host '<could not parse final JSON>' }
                  throw "Sample pipeline run did not succeed (result=$finalResult)"
                }
      - job: Summary
        displayName: Validation Summary
        dependsOn:
          - ValidateLinux
          - ValidateWindows
        condition: succeededOrFailed()
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          - name: linuxResult
            value: $[ dependencies.ValidateLinux.result ]
          - name: windowsResult
            value: $[ dependencies.ValidateWindows.result ]
          - name: linuxRunId
            value: $[ dependencies.ValidateLinux.outputs['TriggerSample.sampleRunId'] ]
          - name: linuxRunUrl
            value: $[ dependencies.ValidateLinux.outputs['TriggerSample.sampleRunUrl'] ]
          - name: windowsRunId
            value: $[ dependencies.ValidateWindows.outputs['TriggerSample.sampleRunId'] ]
          - name: windowsRunUrl
            value: $[ dependencies.ValidateWindows.outputs['TriggerSample.sampleRunUrl'] ]
        steps:
          - download: deployAgentsHelm
            artifact: agent-config
          - task: PowerShell@2
            displayName: Emit validation summary
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                $instance = 'unknown'
                $deployLinux = 'False'
                $deployWindows = 'False'
                $org = ''
                if(Test-Path $cfgPath){
                  $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                  $instance = $cfg.instanceNumber
                  $deployLinux = $cfg.deployLinux
                  $deployWindows = $cfg.deployWindows
                  $org = $cfg.azureDevOpsOrgUrl
                }

                $linuxRes = '$(linuxResult)'
                $winRes = '$(windowsResult)'
                $linuxRunId = '$(linuxRunId)'
                $linuxRunUrl = '$(linuxRunUrl)'
                $windowsRunId = '$(windowsRunId)'
                $windowsRunUrl = '$(windowsRunUrl)'

                $lines = @('# Validation Summary', "Instance: $instance", "Azure DevOps Org: $org")
                if($deployLinux -eq $true -or $deployLinux -eq 'True'){ 
                  $lines += "Linux test result: $linuxRes"
                  if($linuxRunId){ $lines += "Linux sample run id: $linuxRunId" }
                  if($linuxRunUrl){ $lines += "Linux sample run URL: $linuxRunUrl" }
                } else { $lines += 'Linux deployment skipped' }
                if($deployWindows -eq $true -or $deployWindows -eq 'True'){
                  $lines += "Windows test result: $winRes"
                  if($windowsRunId){ $lines += "Windows sample run id: $windowsRunId" }
                  if($windowsRunUrl){ $lines += "Windows sample run URL: $windowsRunUrl" }
                } else { $lines += 'Windows deployment skipped' }

                $out = Join-Path $env:SYSTEM_DEFAULTWORKINGDIRECTORY 'validation-summary.md'
                $lines | Out-File $out -Encoding utf8
                Write-Host "##vso[task.addattachment type=Distributedtask.Core.Summary;name=Agent Validation]$out"
                $lines | ForEach-Object { Write-Host $_ }
