# Separate pipeline to validate newly deployed self-hosted agents
# This pipeline is triggered by the completion of the deploy-selfhosted-agents pipeline as a pipeline resource.
# It downloads the 'agent-config' artifact (config.json) and uses its values to know which pools to validate.

# Short description: Validate that deployed self-hosted agent pools (Linux/Windows) come online and
# trigger a small sample pipeline on each pool to confirm agents can run jobs. Set the
# `useOnPremAgents` parameter to true to run the validation jobs on an on-prem agent pool
# named 'UbuntuLatestPoolOnPrem' instead of using the hosted `ubuntu-latest` pool.

trigger: none
pr: none

parameters:
  - name: linuxHelloWaitSeconds
    type: number
    default: 120
  - name: windowsHelloWaitSeconds
    type: number
    default: 120
  - name: useOnPremAgents
    type: boolean
    default: false # Set to true to use on-premises agents, false to use cloud agents
  - name: useAzureLocal
    type: boolean
    default: false
resources:
  pipelines:
    - pipeline: deployAgentsHelm
      source: DevOpsAgentswithK8S-deploy-self-hosted-agents-helm
      trigger: true # automatic trigger on successful run of source pipeline

variables:
  - group: "DevOpsAgentswithK8S-003" # to get AZDO_PAT
  - name: samplePipelineNameHelm
    value: DevOpsAgentswithK8S-run-on-selfhosted-pool-sample-helm # changed to helm pipeline name

stages:
  - stage: LoadConfig
    displayName: Load agent-config and compute pool names
    jobs:
      - job: LoadConfig
        displayName: Load configuration artifact
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        steps:
          - download: deployAgentsHelm
            artifact: agent-config
          - task: PowerShell@2
            name: ParseConfig
            displayName: Parse config.json and compute pools
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $path = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                if(-not (Test-Path $path)){ throw "Config file not found at $path" }
                $cfg = Get-Content $path -Raw | ConvertFrom-Json
                Write-Host "Loaded config:" ($cfg | ConvertTo-Json -Compress)
                # Export as job output variables so downstream jobs can reference them
                $instance = $cfg.instanceNumber
                Write-Host "##vso[task.setvariable variable=instanceNumber;isOutput=true]$instance"
                Write-Host "Exported instanceNumber=$instance"
                Write-Host "##vso[task.setvariable variable=deployLinux;isOutput=true]$($cfg.deployLinux)"
                Write-Host "Exported deployLinux=$($cfg.deployLinux)"
                Write-Host "##vso[task.setvariable variable=deployWindows;isOutput=true]$($cfg.deployWindows)"
                Write-Host "Exported deployWindows=$($cfg.deployWindows)"
                Write-Host "##vso[task.setvariable variable=azureDevOpsOrgUrl;isOutput=true]$($cfg.azureDevOpsOrgUrl)"
                Write-Host "Exported azureDevOpsOrgUrl=$($cfg.azureDevOpsOrgUrl)"
                # Normalize useAzureLocal to 'True'/'False' strings for consistent comparison
                $useAzureLocalVal = $false
                try { $useAzureLocalVal = [bool]$cfg.useAzureLocal } catch { $useAzureLocalVal = $false }
                $useStr = if($useAzureLocalVal) { 'True' } else { 'False' }
                Write-Host "##vso[task.setvariable variable=useAzureLocal;isOutput=true]$useStr"
                Write-Host "Exported useAzureLocal=$useStr"
                # Compute pool names so downstream jobs don't need runtime expressions
                $poolNameLinux = if($useAzureLocalVal) { "KubernetesPoolOnPremLinux$instance" } else { "KubernetesPoolLinux$instance" }
                $poolNameWindows = if($useAzureLocalVal) { "KubernetesPoolOnPremWindows$instance" } else { "KubernetesPoolWindows$instance" }
                Write-Host "##vso[task.setvariable variable=poolNameLinux;isOutput=true]$poolNameLinux"
                Write-Host "Exported poolNameLinux=$poolNameLinux"
                Write-Host "##vso[task.setvariable variable=poolNameWindows;isOutput=true]$poolNameWindows"
                Write-Host "Exported poolNameWindows=$poolNameWindows"

  - stage: Validate
    displayName: Validate self-hosted agent pools
    dependsOn: LoadConfig
    jobs:
      - job: ValidateLinux
        displayName: "Validate Linux self-hosted pool ($[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.poolNameLinux'] ])"
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          - name: instanceNumber
            value: $[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.instanceNumber'] ]
          - name: azureDevOpsOrgUrl
            value: $[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.azureDevOpsOrgUrl'] ]
          - name: useAzureLocal
            value: $[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.useAzureLocal'] ]
          - name: poolName
            value: $[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.poolNameLinux'] ]
          - name: linuxHelloWaitSeconds
            value: ${{ parameters.linuxHelloWaitSeconds }}
        steps:
          - download: deployAgentsHelm
            artifact: agent-config
          - task: PowerShell@2
            name: CheckShouldRun
            displayName: Check if Linux validation should run
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                if(-not (Test-Path $cfgPath)){ Write-Host "Config not found at $cfgPath - assuming skip"; Write-Host "##vso[task.setvariable variable=shouldRun]false"; exit 0 }
                $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                $deploy = $false
                try { $deploy = [bool]$cfg.deployLinux } catch { $deploy = $false }
                # export helpful job variables for subsequent steps
                $instance = $cfg.instanceNumber
                Write-Host "##vso[task.setvariable variable=instanceNumber]$instance"
                $org = $cfg.azureDevOpsOrgUrl
                Write-Host "##vso[task.setvariable variable=azureDevOpsOrgUrl]$org"
                $useLocalVal = $false
                try { $useLocalVal = [bool]$cfg.useAzureLocal } catch { $useLocalVal = $false }
                $useLocalStr = if($useLocalVal) { 'True' } else { 'False' }
                Write-Host "##vso[task.setvariable variable=useAzureLocal]$useLocalStr"
                $poolName = if($useLocalVal) { "KubernetesPoolOnPremLinux$instance" } else { "KubernetesPoolLinux$instance" }
                Write-Host "##vso[task.setvariable variable=poolName]$poolName"
                if($deploy){ Write-Host "##vso[task.setvariable variable=shouldRun]true"; Write-Host "Will run Linux validation" } else { Write-Host "##vso[task.setvariable variable=shouldRun]false"; Write-Host "Skipping Linux validation per config" }
          - task: PowerShell@2
            displayName: "Poll Linux pool ($(poolName))"
            condition: and(succeeded(), eq(variables['shouldRun'], 'true'))
            env:
              AZDO_PAT: $(AZDO_PAT)
              POOL_NAME: $(poolName)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                $poolName = $env:POOL_NAME
                if(-not $poolName){ throw 'POOL_NAME not set' }
                $orgUrl = '$(azureDevOpsOrgUrl)'
                $authHeader = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(':' + $pat))
                $headers = @{ Authorization = $authHeader }
                $apiVersion = '7.1-preview.1'
                # Use pipeline-configurable timeout (seconds). Default set by parameter `linuxHelloWaitSeconds`.
                $maxSeconds = [int] '$(linuxHelloWaitSeconds)'
                $interval = 10
                $elapsed = 0
                Write-Host "Waiting for Linux agent in pool $poolName"
                while($true){
                  $poolResp = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools?poolName=$([Uri]::EscapeDataString($poolName))&api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                  if($poolResp.count -gt 0){
                    $poolId = $poolResp.value[0].id
                    $agents = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools/$poolId/agents?api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                    $online = @($agents.value | Where-Object { $_.status -eq 'online' })
                    if($online.Count -gt 0){ Write-Host "Linux agent online: $($online[0].name)"; break }
                  }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for Linux agent" }
                  Start-Sleep -Seconds $interval; $elapsed += $interval; Write-Host "...still waiting ($elapsed s)";
                }
          - task: PowerShell@2
            name: TriggerSample
            displayName: "Trigger sample pipeline on self-hosted Linux pool ($(poolName))"
            condition: and(succeeded(), eq(variables['shouldRun'], 'true'))
            env:
              AZDO_PAT: $(AZDO_PAT)
              POOL_NAME: $(poolName)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                if(-not (Test-Path $cfgPath)){ throw "Config artifact not found at $cfgPath" }
                $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                $instance = $cfg.instanceNumber
                $orgUrl = $cfg.azureDevOpsOrgUrl
                $project = $env:SYSTEM_TEAMPROJECT

                $pipelineName = '$(samplePipelineNameHelm)'
                Write-Host "Triggering sample pipeline '$pipelineName' for instance $instance (os=linux)"

                $null = & az --version 2>$null
                if($LASTEXITCODE -ne 0){ throw 'Azure CLI (az) not found on PATH; unable to trigger pipeline via az CLI' }
                $ext = (& az extension list --query "[?name=='azure-devops']" -o json) | ConvertFrom-Json
                if(-not $ext){ Write-Host 'Installing azure-devops extension'; az extension add --name azure-devops --yes | Out-Null }

                Write-Host "Configuring az devops defaults: org=$orgUrl project=$project"

                $env:AZURE_DEVOPS_EXT_PAT = $pat
                & az devops configure --defaults organization=$orgUrl project=$project | Out-Null

                # Prefer the job variable (set from ParseConfig)
                $useLocal = $false
                if ('$(useAzureLocal)' -ne '') { $useLocal = '$(useAzureLocal)' -in @('True','true','1') }
                $useLocalParam = if($useLocal) { 'true' } else { 'false' }

                                      
                # Determine branch to use for queuing the sample pipeline (defensive)
                $branch = '$(resources.pipeline.deployAgentsHelm.sourceBranch)'

                # If the resource token was not expanded (literal $[...] or empty), fall back to Build.SourceBranch
                if ($branch -like '$*' -or [string]::IsNullOrWhiteSpace($branch)) {
                  $branch = '$(Build.SourceBranch)'
                }

                # Final fallback to a safe default if still empty
                if ([string]::IsNullOrWhiteSpace($branch)) {
                  $branch = 'refs/heads/main'
                }

                # Convert to short branch name (strip refs/heads/)
                $branch = $branch -replace '^refs/heads/',''
                # ...continue existing code that calls `az pipelines run --branch $branch`...
                $runJson = & az pipelines run --name $pipelineName --branch $branch --parameters instanceNumber=$instance os=linux helloWaitSeconds=$(linuxHelloWaitSeconds) useAzureLocal=$useLocalParam --output json 2>&1

                if($LASTEXITCODE -ne 0){ Write-Error $runJson; throw 'Failed to queue sample pipeline run via az pipelines run' }
                $runObj = $runJson | Out-String | ConvertFrom-Json
                $runId = $runObj.id
                if(-not $runId){ throw 'Could not determine run id from az pipelines run output' }
                Write-Host "Queued pipeline run id: $runId"
                Write-Host "##vso[task.setvariable variable=sampleRunId;isOutput=true]$runId"
                $runUrl = "$orgUrl/$project/_build/results?buildId=$runId&view=results"
                Write-Host "##vso[task.setvariable variable=sampleRunUrl;isOutput=true]$runUrl"

                $state = $null; $result = $null
                $maxSeconds = 1800
                $interval = 5
                $elapsed = 0
                Write-Host "Sample run URL: $runUrl"
                while($true){
                  Start-Sleep -Seconds $interval
                  $elapsed += $interval
                  $showRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                  try{ $showObj = $showRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse az pipelines runs show output: $showRaw"; if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to produce valid status after $maxSeconds seconds (runId=$runId)" }; continue }
                  if($null -eq $showObj){ Write-Host 'No run information yet'; if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to start after $maxSeconds seconds (runId=$runId)" }; continue }
                  $info = if($showObj -is [System.Array]){ $showObj[0] } else { $showObj }
                  if($info.PSObject.Properties.Name -contains 'state'){ $state = $info.state } elseif($info.PSObject.Properties.Name -contains 'status'){ $state = $info.status }
                  if($info.PSObject.Properties.Name -contains 'result'){ $result = $info.result }
                  Write-Host "Sample run state=$state result=$result (elapsed=${elapsed}s)"
                  if($state -in @('completed','canceled','failed')){ break }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to complete after $maxSeconds seconds (runId=$runId). Last known state='$state' result='$result'" }
                }
                $finalRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                $finalObj = $null
                try{ $finalObj = $finalRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse final run show output: $finalRaw" }
                $finalInfo = if($finalObj -is [System.Array]){ $finalObj[0] } else { $finalObj }
                $finalResult = $null
                if($finalInfo -ne $null -and $finalInfo.PSObject.Properties.Name -contains 'result'){ $finalResult = $finalInfo.result }
                if(-not $finalResult){ $finalResult = $result }
                if($finalResult -ne 'succeeded'){
                  Write-Host 'Sample pipeline final run JSON (raw):'
                  Write-Host $finalRaw
                  Write-Host 'Sample pipeline final run object:'
                  if($finalObj){ $finalObj | ConvertTo-Json -Depth 5 | Write-Host } else { Write-Host '<could not parse final JSON>' }
                  # Attempt to fetch timeline and per-step logs for the failed run to aid debugging
                  Write-Host "Attempting to fetch timeline and logs for runId=$runId"
                  try{
                    $timelineRaw = & az rest --method get --uri "$orgUrl/_apis/build/builds/$runId/timeline?api-version=7.1" 2>&1 | Out-String
                    Write-Host "Timeline raw:"
                    Write-Host $timelineRaw
                    try{ $timelineObj = $timelineRaw | ConvertFrom-Json } catch { $timelineObj = $null }
                    if($timelineObj -and $timelineObj.records){
                      foreach($rec in $timelineObj.records){
                        if($rec.log -and $rec.log.id){
                          $logId = $rec.log.id
                          Write-Host "Fetching log id $logId ($($rec.name))"
                          $logRaw = & az rest --method get --uri "$orgUrl/_apis/build/builds/$runId/logs/$logId?api-version=7.1" 2>&1 | Out-String
                          Write-Host "==== Log: $($rec.name) ===="
                          Write-Host $logRaw
                        }
                      }
                    } else {
                      Write-Host 'No timeline records found or failed to parse timeline.'
                    }
                  } catch { Write-Warning "Failed to fetch logs via az rest: $_" }
                  throw "Sample pipeline run did not succeed (result=$finalResult)"
                }
          - task: PowerShell@2
            name: SetJobResult
            displayName: Set Linux job result output
            condition: always()
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $jobStatus = '$(Agent.JobStatus)'
                $sr = '$(sampleRunId)'
                $should = '$(shouldRun)'
                if($jobStatus -ne '' -and $jobStatus -ne 'Succeeded'){
                  Write-Host "##vso[task.setvariable variable=jobResult;isOutput=true]failed"
                  Write-Host "Job status: $jobStatus -> failed"
                } elseif($should -in @('true','True','1')){
                  if($sr -ne ''){ Write-Host "##vso[task.setvariable variable=jobResult;isOutput=true]succeeded"; Write-Host "Job result: succeeded" } else { Write-Host "##vso[task.setvariable variable=jobResult;isOutput=true]failed"; Write-Host "Job result: failed (no run id)" }
                } else {
                  Write-Host "##vso[task.setvariable variable=jobResult;isOutput=true]skipped"
                  Write-Host "Job result: skipped"
                }
      - job: ValidateWindows
        displayName: "Validate Windows self-hosted pool ($[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.poolNameWindows'] ])"
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          - name: instanceNumber
            value: $[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.instanceNumber'] ]
          - name: azureDevOpsOrgUrl
            value: $[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.azureDevOpsOrgUrl'] ]
          - name: useAzureLocal
            value: $[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.useAzureLocal'] ]
          - name: poolName
            value: $[ dependencies.LoadConfig.outputs['LoadConfig.ParseConfig.poolNameWindows'] ]
          - name: windowsHelloWaitSeconds
            value: ${{ parameters.windowsHelloWaitSeconds }}
        steps:
          - download: deployAgentsHelm
            artifact: agent-config
          - task: PowerShell@2
            name: CheckShouldRun
            displayName: Check if Windows validation should run
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                if(-not (Test-Path $cfgPath)){ Write-Host "Config not found at $cfgPath - assuming skip"; Write-Host "##vso[task.setvariable variable=shouldRun]false"; exit 0 }
                $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                $deploy = $false
                try { $deploy = [bool]$cfg.deployWindows } catch { $deploy = $false }
                # export helpful job variables for subsequent steps
                $instance = $cfg.instanceNumber
                Write-Host "##vso[task.setvariable variable=instanceNumber]$instance"
                $org = $cfg.azureDevOpsOrgUrl
                Write-Host "##vso[task.setvariable variable=azureDevOpsOrgUrl]$org"
                $useLocalVal = $false
                try { $useLocalVal = [bool]$cfg.useAzureLocal } catch { $useLocalVal = $false }
                $useLocalStr = if($useLocalVal) { 'True' } else { 'False' }
                Write-Host "##vso[task.setvariable variable=useAzureLocal]$useLocalStr"
                $poolName = if($useLocalVal) { "KubernetesPoolOnPremWindows$instance" } else { "KubernetesPoolWindows$instance" }
                Write-Host "##vso[task.setvariable variable=poolName]$poolName"
                if($deploy){ Write-Host "##vso[task.setvariable variable=shouldRun]true"; Write-Host "Will run Windows validation" } else { Write-Host "##vso[task.setvariable variable=shouldRun]false"; Write-Host "Skipping Windows validation per config" }
          - task: PowerShell@2
            displayName: "Poll Windows pool ($(poolName))"
            condition: and(succeeded(), eq(variables['shouldRun'], 'true'))
            env:
              AZDO_PAT: $(AZDO_PAT)
              POOL_NAME: $(poolName)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                $poolName = $env:POOL_NAME
                if(-not $poolName){ throw 'POOL_NAME not set' }
                $orgUrl = '$(azureDevOpsOrgUrl)'
                $authHeader = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(':' + $pat))
                $headers = @{ Authorization = $authHeader }
                $apiVersion = '7.1-preview.1'
                # Use pipeline-configurable timeout (seconds). Default set by parameter `windowsHelloWaitSeconds`.
                $maxSeconds = [int] '$(windowsHelloWaitSeconds)'
                $interval = 15
                $elapsed = 0
                Write-Host "Waiting for Windows agent in pool $poolName"
                while($true){
                  $poolResp = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools?poolName=$([Uri]::EscapeDataString($poolName))&api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                  if($poolResp.count -gt 0){
                    $poolId = $poolResp.value[0].id
                    $agents = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools/$poolId/agents?api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                    $online = @($agents.value | Where-Object { $_.status -eq 'online' })
                    if($online.Count -gt 0){ Write-Host "Windows agent online: $($online[0].name)"; break }
                  }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for Windows agent" }
                  Start-Sleep -Seconds $interval; $elapsed += $interval; Write-Host "...still waiting ($elapsed s)";
                }
          - task: PowerShell@2
            name: TriggerSample
            displayName: "Trigger sample pipeline on self-hosted Windows pool ($(poolName))"
            condition: and(succeeded(), eq(variables['shouldRun'], 'true'))
            env:
              AZDO_PAT: $(AZDO_PAT)
              POOL_NAME: $(poolName)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                if(-not (Test-Path $cfgPath)){ throw "Config artifact not found at $cfgPath" }
                $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                $instance = $cfg.instanceNumber
                $orgUrl = $cfg.azureDevOpsOrgUrl
                $project = $env:SYSTEM_TEAMPROJECT

                $pipelineName = '$(samplePipelineNameHelm)'
                Write-Host "Triggering sample pipeline '$pipelineName' for instance $instance (os=windows)"

                $null = & az --version 2>$null
                if($LASTEXITCODE -ne 0){ throw 'Azure CLI (az) not found on PATH; unable to trigger pipeline via az CLI' }
                $ext = (& az extension list --query "[?name=='azure-devops']" -o json) | ConvertFrom-Json
                if(-not $ext){ Write-Host 'Installing azure-devops extension'; az extension add --name azure-devops --yes | Out-Null }

                $env:AZURE_DEVOPS_EXT_PAT = $pat
                & az devops configure --defaults organization=$orgUrl project=$project | Out-Null

                # Prefer the job variable (set from ParseConfig)
                $useLocal = $false
                if ('$(useAzureLocal)' -ne '') { $useLocal = '$(useAzureLocal)' -in @('True','true','1') }
                $useLocalParam = if($useLocal) { 'true' } else { 'false' }


                # Determine branch to use for queuing the sample pipeline (defensive)
                $branch = '$(resources.pipeline.deployAgentsHelm.sourceBranch)'

                # If the resource token was not expanded (literal $[...] or empty), fall back to Build.SourceBranch
                if ($branch -like '$*' -or [string]::IsNullOrWhiteSpace($branch)) {
                  $branch = '$(Build.SourceBranch)'
                }

                # Final fallback to a safe default if still empty
                if ([string]::IsNullOrWhiteSpace($branch)) {
                  $branch = 'refs/heads/main'
                }

                # Convert to short branch name (strip refs/heads/)
                $branch = $branch -replace '^refs/heads/',''

                $runJson = & az pipelines run --name $pipelineName --branch $branch --parameters instanceNumber=$instance os=windows helloWaitSeconds=$(windowsHelloWaitSeconds) useAzureLocal=$useLocalParam --output json 2>&1


                if($LASTEXITCODE -ne 0){ Write-Error $runJson; throw 'Failed to queue sample pipeline run via az pipelines run' }
                $runObj = $runJson | Out-String | ConvertFrom-Json
                $runId = $runObj.id
                if(-not $runId){ throw 'Could not determine run id from az pipelines run output' }
                Write-Host "Queued pipeline run id: $runId"
                Write-Host "##vso[task.setvariable variable=sampleRunId;isOutput=true]$runId"
                $runUrl = "$orgUrl/$project/_build/results?buildId=$runId&view=results"
                Write-Host "##vso[task.setvariable variable=sampleRunUrl;isOutput=true]$runUrl"

                $state = $null; $result = $null
                $maxSeconds = 1800
                $interval = 5
                $elapsed = 0
                Write-Host "Sample run URL: $runUrl"
                while($true){
                  Start-Sleep -Seconds $interval
                  $elapsed += $interval
                  $showRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                  try{ $showObj = $showRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse az pipelines runs show output: $showRaw"; if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to produce valid status after $maxSeconds seconds (runId=$runId)" }; continue }
                  if($null -eq $showObj){ Write-Host 'No run information yet'; if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to start after $maxSeconds seconds (runId=$runId)" }; continue }
                  $info = if($showObj -is [System.Array]){ $showObj[0] } else { $showObj }
                  if($info.PSObject.Properties.Name -contains 'state'){ $state = $info.state } elseif($info.PSObject.Properties.Name -contains 'status'){ $state = $info.status }
                  if($info.PSObject.Properties.Name -contains 'result'){ $result = $info.result }
                  Write-Host "Sample run state=$state result=$result (elapsed=${elapsed}s)"
                  if($state -in @('completed','canceled','failed')){ break }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for sample pipeline run to complete after $maxSeconds seconds (runId=$runId). Last known state='$state' result='$result'" }
                }
                $finalRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                $finalObj = $null
                try{ $finalObj = $finalRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse final run show output: $finalRaw" }
                $finalInfo = if($finalObj -is [System.Array]){ $finalObj[0] } else { $finalObj }
                $finalResult = $null
                if($finalInfo -ne $null -and $finalInfo.PSObject.Properties.Name -contains 'result'){ $finalResult = $finalInfo.result }
                if(-not $finalResult){ $finalResult = $result }
                if($finalResult -ne 'succeeded'){
                  Write-Host 'Sample pipeline final run JSON (raw):'
                  Write-Host $finalRaw
                  Write-Host 'Sample pipeline final run object:'
                  if($finalObj){ $finalObj | ConvertTo-Json -Depth 5 | Write-Host } else { Write-Host '<could not parse final JSON>' }
                  # Attempt to fetch timeline and per-step logs for the failed run to aid debugging
                  Write-Host "Attempting to fetch timeline and logs for runId=$runId"
                  try{
                    $timelineRaw = & az rest --method get --uri "$orgUrl/_apis/build/builds/$runId/timeline?api-version=7.1" 2>&1 | Out-String
                    Write-Host "Timeline raw:"
                    Write-Host $timelineRaw
                    try{ $timelineObj = $timelineRaw | ConvertFrom-Json } catch { $timelineObj = $null }
                    if($timelineObj -and $timelineObj.records){
                      foreach($rec in $timelineObj.records){
                        if($rec.log -and $rec.log.id){
                          $logId = $rec.log.id
                          Write-Host "Fetching log id $logId ($($rec.name))"
                          $logRaw = & az rest --method get --uri "$orgUrl/_apis/build/builds/$runId/logs/$logId?api-version=7.1" 2>&1 | Out-String
                          Write-Host "==== Log: $($rec.name) ===="
                          Write-Host $logRaw
                        }
                      }
                    } else {
                      Write-Host 'No timeline records found or failed to parse timeline.'
                    }
                  } catch { Write-Warning "Failed to fetch logs via az rest: $_" }
                  throw "Sample pipeline run did not succeed (result=$finalResult)"
                }
          - task: PowerShell@2
            name: SetJobResult
            displayName: Set Windows job result output
            condition: always()
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $jobStatus = '$(Agent.JobStatus)'
                $sr = '$(sampleRunId)'
                $should = '$(shouldRun)'
                if($jobStatus -ne '' -and $jobStatus -ne 'Succeeded'){
                  Write-Host "##vso[task.setvariable variable=jobResult;isOutput=true]failed"
                  Write-Host "Job status: $jobStatus -> failed"
                } elseif($should -in @('true','True','1')){
                  if($sr -ne ''){ Write-Host "##vso[task.setvariable variable=jobResult;isOutput=true]succeeded"; Write-Host "Job result: succeeded" } else { Write-Host "##vso[task.setvariable variable=jobResult;isOutput=true]failed"; Write-Host "Job result: failed (no run id)" }
                } else {
                  Write-Host "##vso[task.setvariable variable=jobResult;isOutput=true]skipped"
                  Write-Host "Job result: skipped"
                }
  - stage: Summary
    displayName: Validation Summary
    dependsOn: Validate
    condition: succeededOrFailed()
    jobs:
      - job: Summary
        displayName: Validation Summary
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: UbuntuLatestPoolOnPrem
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          - name: linuxResult
            value: $[ dependencies.Validate.outputs['ValidateLinux.SetJobResult.jobResult'] ]
          - name: windowsResult
            value: $[ dependencies.Validate.outputs['ValidateWindows.SetJobResult.jobResult'] ]
          - name: linuxRunId
            value: $[ dependencies.Validate.outputs['ValidateLinux.TriggerSample.sampleRunId'] ]
          - name: linuxRunUrl
            value: $[ dependencies.Validate.outputs['ValidateLinux.TriggerSample.sampleRunUrl'] ]
          - name: windowsRunId
            value: $[ dependencies.Validate.outputs['ValidateWindows.TriggerSample.sampleRunId'] ]
          - name: windowsRunUrl
            value: $[ dependencies.Validate.outputs['ValidateWindows.TriggerSample.sampleRunUrl'] ]
        steps:
          - download: deployAgentsHelm
            artifact: agent-config
          - task: PowerShell@2
            displayName: Emit validation summary
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgentsHelm/agent-config/config.json'
                $instance = 'unknown'
                $deployLinux = 'False'
                $deployWindows = 'False'
                $org = ''
                if(Test-Path $cfgPath){
                  $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                  $instance = $cfg.instanceNumber
                  $deployLinux = $cfg.deployLinux
                  $deployWindows = $cfg.deployWindows
                  $org = $cfg.azureDevOpsOrgUrl
                }

                $linuxRes = '$(linuxResult)'
                $winRes = '$(windowsResult)'
                $linuxRunId = '$(linuxRunId)'
                $linuxRunUrl = '$(linuxRunUrl)'
                $windowsRunId = '$(windowsRunId)'
                $windowsRunUrl = '$(windowsRunUrl)'

                $lines = @('# Validation Summary', "Instance: $instance", "Azure DevOps Org: $org")
                if($deployLinux -eq $true -or $deployLinux -eq 'True'){ 
                  $lines += "Linux test result: $linuxRes"
                  if($linuxRunId){ $lines += "Linux sample run id: $linuxRunId" }
                  if($linuxRunUrl){ $lines += "Linux sample run URL: $linuxRunUrl" }
                } else { $lines += 'Linux deployment skipped' }
                if($deployWindows -eq $true -or $deployWindows -eq 'True'){
                  $lines += "Windows test result: $winRes"
                  if($windowsRunId){ $lines += "Windows sample run id: $windowsRunId" }
                  if($windowsRunUrl){ $lines += "Windows sample run URL: $windowsRunUrl" }
                } else { $lines += 'Windows deployment skipped' }

                $out = Join-Path $env:SYSTEM_DEFAULTWORKINGDIRECTORY 'validation-summary.md'
                $lines | Out-File $out -Encoding utf8
                Write-Host "##vso[task.addattachment type=Distributedtask.Core.Summary;name=Agent Validation]$out"
                $lines | ForEach-Object { Write-Host $_ }
