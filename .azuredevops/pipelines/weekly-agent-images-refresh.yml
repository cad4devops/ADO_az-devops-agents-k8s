## Weekly build & push of Linux & Windows Azure DevOps self-hosted agent images
# Clean canonical pipeline (re-written)
# Features:
#  * Weekly schedule only (no CI trigger)
#  * Semantic version (GitVersion ContinuousDeployment) with fallback yyyyMMdd-shortSha
#  * Optional fail if fallback is used (failOnFallback)
#  * Optional git tag creation v<semver>
#  * Cross-job outputs (SEMVER_EFFECTIVE, SEMVER_MODE)
#  * Preflight ACR permission validation
#  * Separate Linux and Windows build jobs (skip flags)
#  * Digest capture -> manifests artifact
#  * Tag existence verification
#  * tags.json inventory artifact
#  * Optional SBOM placeholder
#  * Optional tooling report stage that inspects built images and publishes to wiki

trigger: none

schedules:
  - cron: "0 2 * * 1" # Monday 02:00 UTC
    displayName: Weekly Rebuild & Push Agents
    branches:
      include:
        - main
    always: true

parameters:
  - name: AZURE_SERVICE_CONNECTION
    type: string
    default: "SvcConnRgScopedProd"
    values:
      - "SvcConnRgScopedProd"
  - name: ACR_NAME
    type: string
    default: "cragents0036o3yuvhlr3ygc"
    values:
      - "cragents0036o3yuvhlr3ygc"
  - name: skipLinux
    type: boolean
    default: false
    displayName: Skip Linux build/push
  - name: skipWindows
    type: boolean
    default: false
    displayName: Skip Windows build/push
  - name: skipBuildStage
    type: boolean
    default: false
    displayName: Skip build & publish jobs (tool report only)
  - name: useGitVersion
    type: boolean
    default: true
    displayName: Use GitVersion for semantic version & create git tag
  - name: createGitTag
    type: boolean
    default: true
    displayName: Create & push git tag when using GitVersion
  - name: generateSbom
    type: boolean
    default: true
    displayName: Generate simple SBOM manifest (placeholder)
  - name: failOnFallback
    type: boolean
    default: true
    displayName: Fail pipeline if GitVersion fallback (date+sha) is used
  - name: useOnPremAgents
    type: boolean
    default: false # Set to true to use on-premises agents, false to use cloud agents
  - name: publishToolReport
    type: boolean
    default: true
    displayName: Publish tool inventory report to wiki
  - name: wikiName
    type: string
    default: "AKS_agents.wiki"
    displayName: Wiki name (required when publishToolReport=true)
  - name: wikiPagePath
    type: string
    default: "agent-images/tooling-report"
    displayName: Wiki page path (required when publishToolReport=true)
  - name: wikiUpdateMessage
    type: string
    default: "Automated agent tooling report update"
    displayName: Wiki update comment
  - name: windowsOnPremPoolName
    type: string
    default: "WindowsLatestPoolOnPrem"
  - name: ubuntuOnPremPoolName
    type: string
    default: "UbuntuLatestPoolOnPrem"

variables:
  - group: ADO_az-devops-agents-k8s-002-azurelocal
  - name: ACR_NAME
    value: ${{ parameters.ACR_NAME }}
  - name: LINUX_REPOSITORY_NAME
    value: linux-sh-agent-dind
  - name: WINDOWS_VERSIONS
    value: 2022,2025
  - name: WINDOWS_DIND_VERSIONS
    value: 2022,2025
  - name: AZURE_SERVICE_CONNECTION
    value: ${{ parameters.AZURE_SERVICE_CONNECTION }}

stages:
  - stage: BuildAndPublish
    displayName: Build & Publish Agent Images
    jobs:
      - job: Versioning
        displayName: Resolve semantic version / tag suffix
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.ubuntuOnPremPoolName }}
          ${{ else }}:
            vmImage: ubuntu-latest
        steps:
          - checkout: self
            fetchDepth: 0
            persistCredentials: true
          - pwsh: |
              $ErrorActionPreference = 'Stop'
              Write-Host '--- Versioning Step ---'
              $fallback = (Get-Date -Format 'yyyyMMdd') + '-' + (git rev-parse --short=7 HEAD)
              $effective = $null
              $mode = 'Unknown'
              # Convert template parameters to proper booleans for PowerShell logic
              $useGitVersion   = [System.Convert]::ToBoolean('${{ parameters.useGitVersion }}')
              $createGitTag    = [System.Convert]::ToBoolean('${{ parameters.createGitTag }}')
              $failOnFallback  = [System.Convert]::ToBoolean('${{ parameters.failOnFallback }}')

              if (-not $useGitVersion) {
                Write-Host 'useGitVersion=false -> using fallback date+sha.'
                $effective = $fallback
                $mode = 'Fallback'
              }
              else {
                $gvCmd = Get-Command dotnet-gitversion -ErrorAction SilentlyContinue
                if(-not $gvCmd){
                  Write-Host 'Installing GitVersion.Tool (dotnet global)...'
                  dotnet tool install --global GitVersion.Tool --version 5.* --ignore-failed-sources | Out-Null
                  $env:PATH += ":$HOME/.dotnet/tools"
                  $gvCmd = Get-Command dotnet-gitversion -ErrorAction SilentlyContinue
                }
                if(-not $gvCmd){ Write-Warning 'GitVersion not available; will fallback.' }
                function Invoke-GV([switch]$AllowRetry){
                  $args = @('/output','json','/nocache')
                  if(Test-Path GitVersion.yml){ $args += @('/config','GitVersion.yml') }
                  $raw = & $gvCmd @args 2>&1
                  if($LASTEXITCODE -ne 0){
                    if($AllowRetry){
                      if(Test-Path .git/shallow){ git fetch --unshallow || git fetch --depth=1000 }
                      $raw = & $gvCmd @args 2>&1
                      if($LASTEXITCODE -ne 0){ return $null }
                    } else { return $null }
                  }
                  try { return ($raw | ConvertFrom-Json) } catch { return $null }
                }
                if($gvCmd){
                  $gv = Invoke-GV -AllowRetry
                  if($gv){
                    $full = $gv.MajorMinorPatch; if(-not $full){ $full = $gv.FullSemVer }
                    $full = ($full -split '-')[0]; $full = ($full -split '\+')[0]
                    if($full -match '^[0-9]+\.[0-9]+\.[0-9]+$'){
                      $effective = $full
                      $mode = 'GitVersion'
                      Write-Host "Semantic version resolved: $full"
                      if ($createGitTag) {
                        $tagName = "v$full"
                        if(git tag --list $tagName){
                          Write-Host "Tag $tagName already exists (no push needed)."
                        }
                        else {
                          git config user.name 'azure-pipeline'
                          git config user.email 'build@local'
                          git tag -a $tagName -m "Automated version tag $full"
                          $accessToken = $env:SYSTEM_ACCESSTOKEN
                          if([string]::IsNullOrWhiteSpace($accessToken)){
                            Write-Warning 'SYSTEM_ACCESSTOKEN not available; cannot push tag (enable "Allow scripts to access OAuth token" or provide a PAT). Tag created locally only.'
                          }
                          else {
                            try {
                              git -c http.extraheader="AUTHORIZATION: bearer $accessToken" push origin $tagName
                              if($LASTEXITCODE -eq 0){
                                Write-Host "Created & pushed tag $tagName"
                                Write-Host "##vso[task.setvariable variable=GIT_TAG_CREATED;isOutput=true]true"
                              } else {
                                Write-Warning "git push exited with code $LASTEXITCODE; tag push skipped."
                              }
                            } catch {
                              Write-Warning ("Failed to push tag {0}: {1}" -f $tagName, $_.Exception.Message)
                            }
                          }
                        }
                      }
                      Write-Host "##vso[task.setvariable variable=SEMVER_MAJOR]$($gv.Major)"
                      Write-Host "##vso[task.setvariable variable=SEMVER_MINOR]$($gv.Minor)"
                      Write-Host "##vso[task.setvariable variable=SEMVER_PATCH]$($gv.Patch)"
                    } else { Write-Warning "Normalized version invalid -> fallback." }
                  }
                }
              }
              if(-not $effective){ $effective = $fallback; if($mode -eq 'Unknown'){ $mode = 'Fallback' }; Write-Warning "Using fallback tag suffix: $effective" }
              if($mode -eq 'Fallback' -and $useGitVersion){
                Write-Warning 'GitVersion requested but fallback used.'
                if($failOnFallback){ Write-Error 'Failing because failOnFallback=true and semantic version could not be resolved.' }
              }
              Write-Host "Using effective tag suffix: $effective (mode=$mode)"
              Write-Host "##vso[task.setvariable variable=GLOBAL_TAG_SUFFIX]$effective"
              Write-Host "##vso[task.setvariable variable=SEMVER_EFFECTIVE;isOutput=true]$effective"
              Write-Host "##vso[task.setvariable variable=SEMVER_MODE;isOutput=true]$mode"
            name: SetSemVer
            displayName: Resolve & output tag suffix
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
          - pwsh: |
              $skipLinux = [System.Convert]::ToBoolean('${{ parameters.skipLinux }}')
              $skipWindows = [System.Convert]::ToBoolean('${{ parameters.skipWindows }}')
              $skipBuildStage = [System.Convert]::ToBoolean('${{ parameters.skipBuildStage }}')
              if ($skipBuildStage) {
                Write-Host 'skipBuildStage=true -> build & publish jobs will be skipped.'
              }
              if (-not $skipBuildStage -and $skipLinux -and $skipWindows) {
                Write-Error 'Both skipLinux and skipWindows are true; nothing to build.'
              }
              else {
                Write-Host "Skip combination valid. (skipLinux=$skipLinux, skipWindows=$skipWindows, skipBuildStage=$skipBuildStage)"
                if ($skipBuildStage -and (-not $skipLinux -or -not $skipWindows)) {
                  Write-Host 'skipBuildStage overrides per-OS skip flags for build jobs.'
                }
              }
            displayName: Validate skip parameters

      - job: Preflight
        displayName: "Preflight: Validate ACR & Permissions"
        dependsOn: [Versioning]
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.ubuntuOnPremPoolName }}
          ${{ else }}:
            vmImage: ubuntu-latest
        steps:
          - checkout: self
          - task: AzureCLI@2
            name: PreflightVars
            displayName: Check ACR existence & permissions
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: true
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; if(-not $acrFqdn){ throw 'ACR_NAME variable is empty' }
                $acrShort = $acrFqdn.Split('.')[0]
                Write-Host "Preflight validating ACR: $acrShort ($acrFqdn)"
                az acr show --name $acrShort --only-show-errors 1>$null 2>$null || throw "ACR $acrShort not accessible or does not exist"
                az acr repository list --name $acrShort --top 1 --output tsv 1>$null 2>$null || throw 'Unable to list repositories - insufficient ACR permissions'
                az acr login --name $acrShort 1>$null 2>$null || throw 'acr login failed'
                $token = az acr login --name $acrShort --expose-token --output tsv --query accessToken 2>$null
                if(-not $token){ throw 'Failed to obtain ACR access token (push permission may be missing)' }
                Write-Host 'ACR permissions validated.'
                Write-Host "##vso[task.setvariable variable=ACR_READY;isOutput=true]true"

          - task: AzureCLI@2
            name: DetectAcrCommand
            displayName: Detect working ACR manifest command
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; if(-not $acrFqdn){ Write-Warning 'ACR_NAME empty'; Write-Host "##vso[task.setvariable variable=ACR_DIGEST_COMMAND;isOutput=true]az acr repository show-manifests --name <acr> --repository <repo> --output json"; exit 0 }
                $acrShort = $acrFqdn.Split('.')[0]
                $repo = "$(LINUX_REPOSITORY_NAME)"
                if(-not $repo){ $repo = az acr repository list --name $acrShort --top 1 -o tsv }
                $fqRepo = "$acrFqdn/$repo"
                $candidates = @(
                  "az acr repository show-manifests --name $acrShort --repository $repo --output json",
                  "az acr repository show-manifests --name $acrShort $fqRepo --output json",
                  "az acr manifest list-metadata --name $acrShort $fqRepo --output json",
                  "az acr manifest list-metadata --name $acrShort --repository $repo --output json",
                  "az acr repository show-tags --name $acrShort --repository $repo --output json"
                )
                $found = $false
                foreach($cmd in $candidates){
                  Write-Host "Trying: $cmd"
                  try{ $out = bash -lc "$cmd" 2>&1; $rc = $LASTEXITCODE } catch { $out = $_.Exception.Message; $rc = 1 }
                  if($rc -ne 0){ Write-Host "Non-zero exit: $rc"; continue }
                  $outStr = if($out -is [System.Array]) { $out -join "`n" } else { [string]$out }
                  $firstBracket = $outStr.IndexOf('[')
                  if($firstBracket -ge 0){ $jsonText = $outStr.Substring($firstBracket) } else { $jsonText = $outStr }
                  try{
                    $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop
                    $arr = if($obj -is [System.Array]){ $obj } else { @($obj) }
                    foreach($i in $arr){
                      if($i.PSObject.Properties.Name -contains 'digest'){ $found = $true; break }
                      if($i.PSObject.Properties.Name -contains 'value' -and $i.value -is [System.Array]){
                        foreach($v in $i.value){ if($v.PSObject.Properties.Name -contains 'digest'){ $found = $true; break } }
                        if($found){ break }
                      }
                    }
                  } catch { }
                  if(-not $found){ $m = [regex]::Match($outStr, 'sha256:[a-f0-9]{64}'); if($m.Success){ $found = $true } }
                  if($found){
                    Write-Host "Detected working command: $cmd"
                    Write-Host "##vso[task.setvariable variable=ACR_DIGEST_COMMAND;isOutput=true]$cmd"
                    break
                  }
                }
                if(-not $found){
                  Write-Warning 'No working ACR manifest command detected; defaulting to show-manifests --repository'
                  Write-Host "##vso[task.setvariable variable=ACR_DIGEST_COMMAND;isOutput=true]az acr repository show-manifests --name $acrShort --repository $repo --output json"
                }
                exit 0

      - job: LinuxAgentImage
        displayName: Linux Agent Image Build & Push
        dependsOn: [Versioning, Preflight]
        condition: and(succeeded(), eq(dependencies.Preflight.outputs['PreflightVars.ACR_READY'],'true'), eq(${{ parameters.skipLinux }}, false), eq(${{ parameters.skipBuildStage }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.ubuntuOnPremPoolName }}
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          EFFECTIVE_TAG_SUFFIX: $[ dependencies.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          DETECTED_ACR_CMD: $[ dependencies.Preflight.outputs['DetectAcrCommand.ACR_DIGEST_COMMAND'] ]
        steps:
          - checkout: self
            clean: true
          - pwsh: |
              Write-Host "[LinuxAgentImage] EFFECTIVE_TAG_SUFFIX=$env:EFFECTIVE_TAG_SUFFIX"
              if(-not $env:EFFECTIVE_TAG_SUFFIX){ Write-Warning 'EFFECTIVE_TAG_SUFFIX is empty - semantic tag will not be added.' }
            displayName: Debug tag suffix (Linux)
          - task: AzureCLI@2
            name: BuildLinux
            displayName: Run Linux build script
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: scriptPath
              scriptPath: azsh-linux-agent/01-build-and-push.ps1
              arguments: -DefaultAcr $(ACR_NAME)
              workingDirectory: azsh-linux-agent
              failOnStandardError: false
            env:
              ACR_NAME: $(ACR_NAME)
              LINUX_REPOSITORY_NAME: $(LINUX_REPOSITORY_NAME)
              TAG_SUFFIX: $(EFFECTIVE_TAG_SUFFIX)
              SEMVER_EFFECTIVE: $(EFFECTIVE_TAG_SUFFIX)
          - publish: azsh-linux-agent
            artifact: linux-build-context
            condition: succeededOrFailed()
          - pwsh: |
              $ErrorActionPreference='Stop'
              $tag = '$(EFFECTIVE_TAG_SUFFIX)'
              if(-not $tag){ Write-Warning 'No tag suffix -> skip digest.'; exit 0 }
            displayName: Pre-digest validation (Linux)
          - task: AzureCLI@2
            displayName: Capture Linux image digest (ACR auth)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; if(-not $acrFqdn){ Write-Error 'ACR_NAME empty'; exit 1 }
                $acr=$acrFqdn.Split('.')[0]
                $repo = "$(LINUX_REPOSITORY_NAME)"
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                if(-not $tag){ Write-Host 'No effective tag; exiting.'; exit 0 }
                Write-Host ("Collecting digest for {0}:{1}" -f $repo,$tag)
                $digest = $null
                $detected = "$(DETECTED_ACR_CMD)"
                if([string]::IsNullOrWhiteSpace($detected)){
                  Write-Host 'No detected ACR_DIGEST_COMMAND from Preflight; using default show-manifests --repository'
                  $detected = "az acr repository show-manifests --name $acr --repository $repo --output json"
                }
                $jmes2 = "[?tags[?@=='{0}']].digest" -f $tag
                $cmd = $detected.Replace('<acr>',$acr).Replace('<repo>',$repo)
                if(-not ($cmd -match '--query')){ $cmd = "$cmd --query `"$jmes2`" -o tsv" }
                $digest = bash -lc "$cmd" 2>&1 | Select-Object -First 1
                if(-not $digest){ Write-Warning ("Digest not found for {0}:{1}" -f $repo,$tag) }
                New-Item -ItemType Directory -Force -Path $(Pipeline.Workspace)/manifests | Out-Null
                ("{0}:{1}={2}" -f $repo,$tag,$digest) | Out-File $(Pipeline.Workspace)/manifests/linux-digest.txt -Encoding utf8

      - job: WindowsAgentImage_2022
        displayName: Windows Agent Image Build & Push (2022)
        dependsOn: [Versioning, Preflight]
        condition: and(succeeded(), eq(dependencies.Preflight.outputs['PreflightVars.ACR_READY'],'true'), eq(${{ parameters.skipWindows }}, false), eq(${{ parameters.skipBuildStage }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.windowsOnPremPoolName }}
          ${{ else }}:
            vmImage: windows-latest
        variables:
          WIN_VERSION: "2022"
          EFFECTIVE_TAG_SUFFIX: $[ dependencies.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          DETECTED_ACR_CMD: $[ dependencies.Preflight.outputs['DetectAcrCommand.ACR_DIGEST_COMMAND'] ]
        steps:
          - checkout: self
            clean: true
          - pwsh: |
              Write-Host "[WindowsAgentImage 2022] EFFECTIVE_TAG_SUFFIX=$env:EFFECTIVE_TAG_SUFFIX"
              if(-not $env:EFFECTIVE_TAG_SUFFIX){ Write-Warning 'EFFECTIVE_TAG_SUFFIX is empty - semantic tag will not be added.' }
            displayName: Debug tag suffix (Windows 2022)
          - task: AzureCLI@2
            name: BuildWindows2022
            displayName: Run Windows build script (2022)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: scriptPath
              scriptPath: azsh-windows-agent/01-build-and-push.ps1
              arguments: -DefaultAcr $(ACR_NAME) -WindowsVersions $(WIN_VERSION)
              workingDirectory: azsh-windows-agent
              failOnStandardError: false
            env:
              ACR_NAME: $(ACR_NAME)
              TAG_SUFFIX: $(EFFECTIVE_TAG_SUFFIX)
              SEMVER_EFFECTIVE: $(EFFECTIVE_TAG_SUFFIX)
              WINDOWS_VERSIONS: $(WIN_VERSION)
              WIN_VERSION: $(WIN_VERSION)
          - publish: azsh-windows-agent
            artifact: windows-build-context-2022
            condition: succeededOrFailed()
          - task: AzureCLI@2
            displayName: Capture Windows image digests (2022)
            name: CaptureWindowsDigests2022
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; if(-not $acrFqdn){ Write-Error 'ACR_NAME empty'; exit 1 }
                $acr = $acrFqdn.Split('.')[0]
                $tag = '$(EFFECTIVE_TAG_SUFFIX)'
                if(-not $tag){ Write-Warning 'No EFFECTIVE_TAG_SUFFIX provided; skipping digest capture.'; exit 0 }
                $win = "$(WIN_VERSION)".Trim()
                if(-not $win){ Write-Warning 'WIN_VERSION not set for this job; skipping.'; exit 0 }
                $repo = "windows-sh-agent-$win"
                New-Item -ItemType Directory -Force -Path $(Pipeline.Workspace)/manifests | Out-Null
                Write-Host ("Collecting digest for {0}:{1}" -f $repo,$tag)
                $digest = $null
                $detected = "$(DETECTED_ACR_CMD)"
                if([string]::IsNullOrWhiteSpace($detected)){
                  Write-Host 'No detected ACR_DIGEST_COMMAND from Preflight; using default show-manifests --repository'
                  $detected = "az acr repository show-manifests --name $acr --repository $repo --output json"
                }
                $jmes2 = "[?tags[?@=='{0}']].digest" -f $tag
                $cmd = $detected.Replace('<acr>',$acr).Replace('<repo>',$repo)
                if(-not ($cmd -match '--query')){ $cmd = "$cmd --query `"$jmes2`" -o tsv" }
                $digest = bash -lc "$cmd" 2>&1 | Select-Object -First 1
                if(-not $digest){
                  Write-Warning ("Digest not found for {0}:{1}" -f $repo,$tag)
                  $digestOut = ''
                } else {
                  Write-Host ("Digest for {0}:{1} -> {2}" -f $repo,$tag,$digest)
                  $digestOut = $digest
                }
                ("{0}:{1}={2}" -f $repo,$tag,$digestOut) | Out-File $(Pipeline.Workspace)/manifests/windows-$win-digest.txt -Encoding utf8
                Write-Host 'Windows digests collection complete.'

      - job: WindowsAgentImage_2025
        displayName: Windows Agent Image Build & Push (2025)
        dependsOn: [Versioning, Preflight]
        condition: and(succeeded(), eq(dependencies.Preflight.outputs['PreflightVars.ACR_READY'],'true'), eq(${{ parameters.skipWindows }}, false), eq(${{ parameters.skipBuildStage }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.windowsOnPremPoolName }}
          ${{ else }}:
            vmImage: windows-latest
        variables:
          WIN_VERSION: "2025"
          EFFECTIVE_TAG_SUFFIX: $[ dependencies.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          DETECTED_ACR_CMD: $[ dependencies.Preflight.outputs['DetectAcrCommand.ACR_DIGEST_COMMAND'] ]
        steps:
          - checkout: self
            clean: true
          - pwsh: |
              Write-Host "[WindowsAgentImage 2025] EFFECTIVE_TAG_SUFFIX=$env:EFFECTIVE_TAG_SUFFIX"
              if(-not $env:EFFECTIVE_TAG_SUFFIX){ Write-Warning 'EFFECTIVE_TAG_SUFFIX is empty - semantic tag will not be added.' }
            displayName: Debug tag suffix (Windows 2025)
          - task: AzureCLI@2
            name: BuildWindows2025
            displayName: Run Windows build script (2025)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: scriptPath
              scriptPath: azsh-windows-agent/01-build-and-push.ps1
              arguments: -DefaultAcr $(ACR_NAME) -WindowsVersions $(WIN_VERSION)
              workingDirectory: azsh-windows-agent
              failOnStandardError: false
            env:
              ACR_NAME: $(ACR_NAME)
              TAG_SUFFIX: $(EFFECTIVE_TAG_SUFFIX)
              SEMVER_EFFECTIVE: $(EFFECTIVE_TAG_SUFFIX)
              WINDOWS_VERSIONS: $(WIN_VERSION)
              WIN_VERSION: $(WIN_VERSION)
          - publish: azsh-windows-agent
            artifact: windows-build-context-2025
            condition: succeededOrFailed()
          - task: AzureCLI@2
            displayName: Capture Windows image digests (2025)
            name: CaptureWindowsDigests2025
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; if(-not $acrFqdn){ Write-Error 'ACR_NAME empty'; exit 1 }
                $acr = $acrFqdn.Split('.')[0]
                $tag = '$(EFFECTIVE_TAG_SUFFIX)'
                if(-not $tag){ Write-Warning 'No EFFECTIVE_TAG_SUFFIX provided; skipping digest capture.'; exit 0 }
                $versions = "$(WINDOWS_VERSIONS)".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
                New-Item -ItemType Directory -Force -Path $(Pipeline.Workspace)/manifests | Out-Null
                foreach($v in $versions){
                  $repo = "windows-sh-agent-$v"
                  Write-Host ("Collecting digest for {0}:{1}" -f $repo,$tag)
                  $digest = $null
                  $detected = "$(DETECTED_ACR_CMD)"
                  if([string]::IsNullOrWhiteSpace($detected)){
                    Write-Host 'No detected ACR_DIGEST_COMMAND from Preflight; using default show-manifests --repository'
                    $detected = "az acr repository show-manifests --name $acr --repository $repo --output json"
                  }
                  $jmes2 = "[?tags[?@=='{0}']].digest" -f $tag
                  $cmd = $detected.Replace('<acr>',$acr).Replace('<repo>',$repo)
                  if(-not ($cmd -match '--query')){ $cmd = "$cmd --query `"$jmes2`" -o tsv" }
                  $digest = bash -lc "$cmd" 2>&1 | Select-Object -First 1
                  if(-not $digest){
                    Write-Warning ("Digest not found for {0}:{1}" -f $repo,$tag)
                    $digestOut = ''
                  } else {
                    Write-Host ("Digest for {0}:{1} -> {2}" -f $repo,$tag,$digest)
                    $digestOut = $digest
                  }
                  ("{0}:{1}={2}" -f $repo,$tag,$digestOut) | Out-File $(Pipeline.Workspace)/manifests/windows-$v-digest.txt -Encoding utf8
                }
                Write-Host 'Windows digests collection complete.'

      - job: WindowsDinDAgentImage_2022
        displayName: Windows DinD Agent Image Build & Push (2022)
        dependsOn: [Versioning, Preflight]
        condition: and(succeeded(), eq(dependencies.Preflight.outputs['PreflightVars.ACR_READY'],'true'), eq(${{ parameters.skipWindows }}, false), eq(${{ parameters.skipBuildStage }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.windowsOnPremPoolName }}
          ${{ else }}:
            vmImage: windows-latest
        variables:
          WIN_VERSION: "2022"
          EFFECTIVE_TAG_SUFFIX: $[ dependencies.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          DETECTED_ACR_CMD: $[ dependencies.Preflight.outputs['DetectAcrCommand.ACR_DIGEST_COMMAND'] ]
        steps:
          - checkout: self
            clean: true
          - pwsh: |
              Write-Host "[WindowsDinDAgentImage 2022] EFFECTIVE_TAG_SUFFIX=$env:EFFECTIVE_TAG_SUFFIX"
              if(-not $env:EFFECTIVE_TAG_SUFFIX){ Write-Warning 'EFFECTIVE_TAG_SUFFIX is empty - semantic tag will not be added.' }
            displayName: Debug tag suffix (Windows DinD 2022)
          - task: AzureCLI@2
            name: BuildWindowsDinD2022
            displayName: Run Windows DinD build script (2022)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: scriptPath
              scriptPath: azsh-windows-agent/01-build-and-push.ps1
              arguments: -DefaultAcr $(ACR_NAME) -WindowsVersions $(WIN_VERSION) -UseDinD
              workingDirectory: azsh-windows-agent
              failOnStandardError: false
            env:
              ACR_NAME: $(ACR_NAME)
              TAG_SUFFIX: $(EFFECTIVE_TAG_SUFFIX)
              SEMVER_EFFECTIVE: $(EFFECTIVE_TAG_SUFFIX)
              WINDOWS_VERSIONS: $(WIN_VERSION)
              WIN_VERSION: $(WIN_VERSION)
          - publish: azsh-windows-agent
            artifact: windows-dind-build-context-2022
            condition: succeededOrFailed()
          - task: AzureCLI@2
            displayName: Capture Windows DinD image digests (2022)
            name: CaptureWindowsDinDDigests2022
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; if(-not $acrFqdn){ Write-Error 'ACR_NAME empty'; exit 1 }
                $acr = $acrFqdn.Split('.')[0]
                $tag = '$(EFFECTIVE_TAG_SUFFIX)'
                if(-not $tag){ Write-Warning 'No EFFECTIVE_TAG_SUFFIX provided; skipping digest capture.'; exit 0 }
                $win = "$(WIN_VERSION)".Trim()
                if(-not $win){ Write-Warning 'WIN_VERSION not set for this job; skipping.'; exit 0 }
                $repo = "windows-sh-agent-$win-dind"
                New-Item -ItemType Directory -Force -Path $(Pipeline.Workspace)/manifests | Out-Null
                Write-Host ("Collecting digest for {0}:{1}" -f $repo,$tag)
                $detected = "$(DETECTED_ACR_CMD)"
                if([string]::IsNullOrWhiteSpace($detected)){
                  Write-Host 'No detected ACR_DIGEST_COMMAND from Preflight; using default show-manifests --repository'
                  $detected = "az acr repository show-manifests --name $acr --repository $repo --output json"
                }
                $jmes2 = "[?tags[?@=='{0}']].digest" -f $tag
                $cmd = $detected.Replace('<acr>',$acr).Replace('<repo>',$repo)
                if(-not ($cmd -match '--query')){ $cmd = "$cmd --query `"$jmes2`" -o tsv" }
                $digest = bash -lc "$cmd" 2>&1 | Select-Object -First 1
                if(-not $digest){
                  Write-Warning ("Digest not found for {0}:{1}" -f $repo,$tag)
                  $digestOut = ''
                } else {
                  Write-Host ("Digest for {0}:{1} -> {2}" -f $repo,$tag,$digest)
                  $digestOut = $digest
                }
                ("{0}:{1}={2}" -f $repo,$tag,$digestOut) | Out-File $(Pipeline.Workspace)/manifests/windows-$win-dind-digest.txt -Encoding utf8
                Write-Host 'Windows DinD digests collection complete.'

      - job: WindowsDinDAgentImage_2025
        displayName: Windows DinD Agent Image Build & Push (2025)
        dependsOn: [Versioning, Preflight]
        condition: and(succeeded(), eq(dependencies.Preflight.outputs['PreflightVars.ACR_READY'],'true'), eq(${{ parameters.skipWindows }}, false), eq(${{ parameters.skipBuildStage }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.windowsOnPremPoolName }}
          ${{ else }}:
            vmImage: windows-latest
        variables:
          WIN_VERSION: "2025"
          EFFECTIVE_TAG_SUFFIX: $[ dependencies.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          DETECTED_ACR_CMD: $[ dependencies.Preflight.outputs['DetectAcrCommand.ACR_DIGEST_COMMAND'] ]
        steps:
          - checkout: self
            clean: true
          - pwsh: |
              Write-Host "[WindowsDinDAgentImage 2025] EFFECTIVE_TAG_SUFFIX=$env:EFFECTIVE_TAG_SUFFIX"
              if(-not $env:EFFECTIVE_TAG_SUFFIX){ Write-Warning 'EFFECTIVE_TAG_SUFFIX is empty - semantic tag will not be added.' }
            displayName: Debug tag suffix (Windows DinD 2025)
          - task: AzureCLI@2
            name: BuildWindowsDinD2025
            displayName: Run Windows DinD build script (2025)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: scriptPath
              scriptPath: azsh-windows-agent/01-build-and-push.ps1
              arguments: -DefaultAcr $(ACR_NAME) -WindowsVersions $(WIN_VERSION) -UseDinD
              workingDirectory: azsh-windows-agent
              failOnStandardError: false
            env:
              ACR_NAME: $(ACR_NAME)
              TAG_SUFFIX: $(EFFECTIVE_TAG_SUFFIX)
              SEMVER_EFFECTIVE: $(EFFECTIVE_TAG_SUFFIX)
              WINDOWS_VERSIONS: $(WIN_VERSION)
              WIN_VERSION: $(WIN_VERSION)
          - publish: azsh-windows-agent
            artifact: windows-dind-build-context-2025
            condition: succeededOrFailed()
          - task: AzureCLI@2
            displayName: Capture Windows DinD image digests (2025)
            name: CaptureWindowsDinDDigests2025
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; if(-not $acrFqdn){ Write-Error 'ACR_NAME empty'; exit 1 }
                $acr = $acrFqdn.Split('.')[0]
                $tag = '$(EFFECTIVE_TAG_SUFFIX)'
                if(-not $tag){ Write-Warning 'No EFFECTIVE_TAG_SUFFIX provided; skipping digest capture.'; exit 0 }
                $win = "$(WIN_VERSION)".Trim()
                if(-not $win){ Write-Warning 'WIN_VERSION not set for this job; skipping.'; exit 0 }
                $repo = "windows-sh-agent-$win-dind"
                New-Item -ItemType Directory -Force -Path $(Pipeline.Workspace)/manifests | Out-Null
                Write-Host ("Collecting digest for {0}:{1}" -f $repo,$tag)
                $detected = "$(DETECTED_ACR_CMD)"
                if([string]::IsNullOrWhiteSpace($detected)){
                  Write-Host 'No detected ACR_DIGEST_COMMAND from Preflight; using default show-manifests --repository'
                  $detected = "az acr repository show-manifests --name $acr --repository $repo --output json"
                }
                $jmes2 = "[?tags[?@=='{0}']].digest" -f $tag
                $cmd = $detected.Replace('<acr>',$acr).Replace('<repo>',$repo)
                if(-not ($cmd -match '--query')){ $cmd = "$cmd --query `"$jmes2`" -o tsv" }
                $digest = bash -lc "$cmd" 2>&1 | Select-Object -First 1
                if(-not $digest){
                  Write-Warning ("Digest not found for {0}:{1}" -f $repo,$tag)
                  $digestOut = ''
                } else {
                  Write-Host ("Digest for {0}:{1} -> {2}" -f $repo,$tag,$digest)
                  $digestOut = $digest
                }
                ("{0}:{1}={2}" -f $repo,$tag,$digestOut) | Out-File $(Pipeline.Workspace)/manifests/windows-$win-dind-digest.txt -Encoding utf8
                Write-Host 'Windows DinD digests collection complete.'

      - job: Summary
        displayName: Summary & Verification
        dependsOn:
          - Versioning
          - Preflight
          - LinuxAgentImage
          - WindowsAgentImage_2022
          - WindowsAgentImage_2025
          - WindowsDinDAgentImage_2022
          - WindowsDinDAgentImage_2025
        condition: and(succeededOrFailed(), eq(${{ parameters.skipBuildStage }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.ubuntuOnPremPoolName }}
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          EFFECTIVE_TAG_SUFFIX: $[ dependencies.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          SEMVER_MODE: $[ dependencies.Versioning.outputs['SetSemVer.SEMVER_MODE'] ]
        steps:
          - task: AzureCLI@2
            displayName: Show image tags & digests
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference = 'Stop'
                $acrFqdn = "$(ACR_NAME)"; if(-not $acrFqdn){ Write-Error 'ACR_NAME variable empty'; exit 1 }
                $acr = $acrFqdn.Split('.')[0]
                Write-Host "ACR: $acrFqdn"
                Write-Host "Effective tag suffix: $(EFFECTIVE_TAG_SUFFIX)"
                Write-Host "Semantic version mode: $(SEMVER_MODE)"
                $skipLinux = [System.Convert]::ToBoolean('${{ parameters.skipLinux }}')
                $skipWindows = [System.Convert]::ToBoolean('${{ parameters.skipWindows }}')
                function Invoke-AzSafe($label, [scriptblock]$block){ Write-Host "--- $label ---"; try { & $block } catch { Write-Warning "$label failed: $($_.Exception.Message)" } }
                Invoke-AzSafe 'Repository list' { az acr repository list --name $acr --output table }
                if(-not $skipLinux){ Invoke-AzSafe 'Linux tags (latest 20)' { az acr repository show-tags --name $acr --repository $(LINUX_REPOSITORY_NAME) --top 20 --orderby time_desc --output table } }
                if(-not $skipWindows){
                  $winVersions = "$(WINDOWS_VERSIONS)".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
                  foreach($v in $winVersions){ Invoke-AzSafe "Windows $v tags (latest 10)" { az acr repository show-tags --name $acr --repository "windows-sh-agent-$v" --top 10 --orderby time_desc --output table } }
                  $winDinDVersions = "$(WINDOWS_DIND_VERSIONS)".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
                  foreach($v in $winDinDVersions){ Invoke-AzSafe "Windows DinD $v tags (latest 10)" { az acr repository show-tags --name $acr --repository "windows-sh-agent-$v-dind" --top 10 --orderby time_desc --output table } }
                }
                if(Test-Path $(Pipeline.Workspace)/manifests){
                  Write-Host '--- Image Digests ---'
                  Get-ChildItem $(Pipeline.Workspace)/manifests | ForEach-Object { "$( $_.Name): $(Get-Content $_)" } | Write-Host
                } else { Write-Host 'No manifest directory found.' }
          - pwsh: |
              $manifests = Test-Path "$(Pipeline.Workspace)/manifests"
              $sbom = Test-Path "$(Pipeline.Workspace)/sbom"
              Write-Host "Manifests directory present: $manifests"
              Write-Host "SBOM directory present: $sbom"
              $manifestsStr = $manifests.ToString().ToLower()
              $sbomStr = $sbom.ToString().ToLower()
              Write-Host "##vso[task.setvariable variable=HAS_MANIFESTS]$manifestsStr"
              Write-Host "##vso[task.setvariable variable=HAS_SBOM]$sbomStr"
            displayName: Detect artifact directories
          - pwsh: |
              $generateSbom = [System.Convert]::ToBoolean('${{ parameters.generateSbom }}')
              if(-not $generateSbom){ Write-Host 'SBOM generation skipped.'; exit 0 }
              New-Item -ItemType Directory -Force -Path $(Pipeline.Workspace)/sbom | Out-Null
              $content = @(
                'SBOM Placeholder',
                "Generated: $(Get-Date -Format o)",
                "Effective Tag Suffix: $(EFFECTIVE_TAG_SUFFIX)",
                "Mode: $(SEMVER_MODE)",
                'Images:'
              )
              if(Test-Path $(Pipeline.Workspace)/manifests){ $content += Get-Content $(Pipeline.Workspace)/manifests/* }
              $content | Out-File $(Pipeline.Workspace)/sbom/sbom.txt -Encoding utf8
              Write-Host 'SBOM placeholder created.'
            displayName: Generate SBOM placeholder
            condition: eq(${{ parameters.generateSbom }}, true)
          - task: AzureCLI@2
            displayName: Verify effective tag exists (Linux repo)
            condition: and(succeededOrFailed(), eq(${{ parameters.skipLinux }}, false))
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; $acr=$acrFqdn.Split('.')[0]
                $repo = "$(LINUX_REPOSITORY_NAME)"
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                Write-Host "Verifying tag '$tag' exists in $repo"
                $tags = az acr repository show-tags --name $acr --repository $repo --top 150 --orderby time_desc -o tsv
                if($tags -notcontains $tag){ Write-Error "Tag $tag not found in $repo" } else { Write-Host 'Tag found.' }
          - task: AzureCLI@2
            displayName: Verify effective tag exists (Windows repos)
            condition: and(succeededOrFailed(), eq(${{ parameters.skipWindows }}, false))
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; $acr=$acrFqdn.Split('.')[0]
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                $versions = "$(WINDOWS_VERSIONS)".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
                foreach($v in $versions){
                  $repo = "windows-sh-agent-$v"
                  Write-Host "Verifying tag '$tag' exists in $repo"
                  $tags = az acr repository show-tags --name $acr --repository $repo --top 200 --orderby time_desc -o tsv
                  if($tags -notcontains $tag){ Write-Error "Tag $tag not found in $repo" } else { Write-Host "Tag found in $repo." }
                }
                $dindVersions = "$(WINDOWS_DIND_VERSIONS)".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
                foreach($v in $dindVersions){
                  $repo = "windows-sh-agent-$v-dind"
                  Write-Host "Verifying tag '$tag' exists in $repo"
                  $tags = az acr repository show-tags --name $acr --repository $repo --top 200 --orderby time_desc -o tsv
                  if($tags -notcontains $tag){ Write-Error "Tag $tag not found in $repo" } else { Write-Host "Tag found in $repo." }
                }
          - task: AzureCLI@2
            displayName: Generate tags.json inventory
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: false
              inlineScript: |
                $ErrorActionPreference='Stop'
                $acrFqdn = "$(ACR_NAME)"; $acr=$acrFqdn.Split('.')[0]
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                $mode = "$(SEMVER_MODE)"
                $skipLinux = [System.Convert]::ToBoolean('${{ parameters.skipLinux }}')
                $skipWindows = [System.Convert]::ToBoolean('${{ parameters.skipWindows }}')
                New-Item -ItemType Directory -Force -Path $(Pipeline.Workspace)/tags | Out-Null
                $obj = [ordered]@{
                  effectiveTagSuffix = $tag
                  generated = (Get-Date -Format o)
                  mode = $mode
                  linux = $null
                  windows = @{}
                  windowsDinD = @{}
                }
                if(-not $skipLinux){
                  $linuxRepo = "$(LINUX_REPOSITORY_NAME)"
                  $linuxTags = az acr repository show-tags --name $acr --repository $linuxRepo --top 200 --orderby time_desc -o tsv
                  $obj.linux = [ordered]@{ repository = $linuxRepo; tags = $linuxTags }
                }
                if(-not $skipWindows){
                  $versions = "$(WINDOWS_VERSIONS)".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
                  foreach($v in $versions){
                    $repo = "windows-sh-agent-$v"
                    $winTags = az acr repository show-tags --name $acr --repository $repo --top 200 --orderby time_desc -o tsv
                    $obj.windows[$repo] = $winTags
                  }
                  $dindVersions = "$(WINDOWS_DIND_VERSIONS)".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
                  foreach($v in $dindVersions){
                    $repo = "windows-sh-agent-$v-dind"
                    $winTags = az acr repository show-tags --name $acr --repository $repo --top 200 --orderby time_desc -o tsv
                    $obj.windowsDinD[$repo] = $winTags
                  }
                }
                ($obj | ConvertTo-Json -Depth 6) | Out-File $(Pipeline.Workspace)/tags/tags.json -Encoding utf8
                Write-Host 'tags.json created.'
                Write-Host "##vso[task.setvariable variable=HAS_TAGS_JSON]true"
          - task: PublishBuildArtifacts@1
            displayName: Publish tag inventory
            condition: and(succeededOrFailed(), eq(variables['HAS_TAGS_JSON'],'true'))
            inputs:
              PathtoPublish: $(Pipeline.Workspace)/tags
              ArtifactName: tags
          - pwsh: |
              $has = Test-Path "$(Pipeline.Workspace)/manifests"
              if(-not $has){ Write-Host 'No manifests directory present; skipping publish.'; exit 0 }
              $files = Get-ChildItem "$(Pipeline.Workspace)/manifests" -File | Select-Object -Expand Name
              Write-Host "Found manifest files: $($files -join ', ')"
              if($files.Count -eq 0){ Write-Host 'No manifest files found; skipping publish.'; exit 0 }
            displayName: Inspect manifests
          - task: PublishBuildArtifacts@1
            displayName: Publish manifests
            condition: and(succeededOrFailed(), eq(variables['HAS_MANIFESTS'],'true'))
            inputs:
              PathtoPublish: $(Pipeline.Workspace)/manifests
              ArtifactName: image-manifests
          - task: PublishBuildArtifacts@1
            displayName: Publish SBOM
            condition: and(succeededOrFailed(), eq(${{ parameters.generateSbom }}, true), eq(variables['HAS_SBOM'],'true'))
            inputs:
              PathtoPublish: $(Pipeline.Workspace)/sbom
              ArtifactName: sbom
          - task: PublishBuildArtifacts@1
            displayName: Publish pipeline workspace (debug dump)
            condition: succeededOrFailed()
            inputs:
              PathtoPublish: $(Pipeline.Workspace)
              ArtifactName: pipeline-workspace-dump

  - stage: ToolReport
    displayName: Publish Agent Tooling Report
    dependsOn: BuildAndPublish
    condition: and(succeeded(), eq(${{ parameters.publishToolReport }}, true))
    jobs:
      - job: ReportLinuxImage
        displayName: Capture Linux tooling inventory
        condition: and(succeeded(), eq(${{ parameters.skipLinux }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.ubuntuOnPremPoolName }}
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          EFFECTIVE_TAG_SUFFIX: $[ stageDependencies.BuildAndPublish.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: Inspect Linux image tooling
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: true
              inlineScript: |
                $ErrorActionPreference = 'Stop'
                $acrFqdn = "$(ACR_NAME)"
                if([string]::IsNullOrWhiteSpace($acrFqdn)){ throw 'ACR_NAME variable empty' }
                $acrShort = $acrFqdn.Split('.')[0]
                if($acrFqdn -notmatch '\.'){
                  $acrFqdn = "$acrShort.azurecr.io"
                  Write-Host ("Normalized ACR FQDN to {0}" -f $acrFqdn)
                }
                $repo = "$(LINUX_REPOSITORY_NAME)"
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                $skipBuildStage = [System.Convert]::ToBoolean('${{ parameters.skipBuildStage }}')

                function Get-LatestTag([string]$acr, [string]$repository){
                  $result = az acr repository show-tags --name $acr --repository $repository --top 20 --orderby time_desc -o tsv 2>&1
                  if($LASTEXITCODE -ne 0){
                    Write-Warning ("Failed to query tags for {0}/{1}: {2}" -f $acr, $repository, ($result -join ' '))
                    return $null
                  }
                  $candidates = @()
                  foreach($line in $result){
                    if([string]::IsNullOrWhiteSpace($line)){ continue }
                    $trimmed = $line.Trim()
                    if(-not [string]::IsNullOrWhiteSpace($trimmed)){ $candidates += $trimmed }
                  }
                  if(-not $candidates){ return $null }
                  $preferred = $candidates | Where-Object { $_ -notin @('latest','Latest','LATEST') }
                  if($preferred){ return $preferred[0] }
                  return $candidates[0]
                }

                if($skipBuildStage){
                  Write-Host 'skipBuildStage=true -> resolving latest published tag for tooling report.'
                  $resolved = Get-LatestTag -acr $acrShort -repository $repo
                  if([string]::IsNullOrWhiteSpace($resolved)){
                    Write-Warning "No tags found for $repo in $acrShort; generating placeholder tooling report."
                    $reportDir = Join-Path "$(Pipeline.Workspace)" 'tool-report'
                    New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
                    $placeholder = @(
                      "## Repository: $repo",
                      "Image: (not available)",
                      "",
                      "_No published tags were found in $acrShort/$repo. Skipping tooling inspection._"
                    )
                    $placeholder | Out-File (Join-Path $reportDir 'linux.md') -Encoding utf8
                    Write-Host 'Linux tooling report placeholder written.'
                    $global:LASTEXITCODE = 0
                    return
                  }
                  $tag = $resolved
                  Write-Host "Resolved existing tag: $tag"
                }
                elseif([string]::IsNullOrWhiteSpace($tag)){
                  throw 'EFFECTIVE_TAG_SUFFIX missing (Versioning stage output unavailable).'
                }

                $image = "{0}/{1}:{2}" -f $acrFqdn, $repo, $tag
                Write-Host "Inspecting Linux image $image"
                az acr login --name $acrShort --only-show-errors | Out-Null
                $pullOutput = & docker pull $image 2>&1
                if($LASTEXITCODE -ne 0){
                  $message = ($pullOutput | Select-Object -First 20) -join [Environment]::NewLine
                  Write-Warning ("docker pull failed for {0}: {1}" -f $image, $message)
                  $reportDir = Join-Path "$(Pipeline.Workspace)" 'tool-report'
                  New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
                  $fallback = @(
                    "## Repository: $repo",
                    "Image: $image",
                    "",
                    "_docker pull failed:_",
                    '```',
                    $message,
                    '```'
                  )
                  $fallback | Out-File (Join-Path $reportDir 'linux.md') -Encoding utf8
                  Write-Host 'Linux tooling report fallback written (docker pull failed).'
                  Write-Host "##vso[task.logissue type=warning]Unable to inspect $image"
                  $global:LASTEXITCODE = 0
                  return
                }
                $pullOutput | Write-Host
                $reportDir = Join-Path "$(Pipeline.Workspace)" 'tool-report'
                New-Item -ItemType Directory -Path $reportDir -Force | Out-Null

                function Invoke-Docker([string]$label, [string[]]$command) {
                  Write-Host "-- $label --"
                  $dockerArgs = @('--rm')
                  if($command -and $command.Count -gt 0){
                    $entrypoint = $command[0]
                    $dockerArgs += @('--entrypoint', $entrypoint, $image)
                    if($command.Count -gt 1){ $dockerArgs += $command[1..($command.Count-1)] }
                  }
                  else {
                    $dockerArgs += $image
                  }
                  $output = & docker run @dockerArgs 2>&1
                  $exitCode = $LASTEXITCODE
                  if ($exitCode -ne 0) {
                    Write-Warning "$label command failed with exit code $exitCode"
                    $details = @("Command: " + ($command -join ' '), "ExitCode: $exitCode")
                    if($output){ $details += ($output | ForEach-Object { $_.ToString() }) }
                    $global:LASTEXITCODE = 0
                    return [string[]]$details
                  }
                  if($output){
                    $global:LASTEXITCODE = 0
                    return [string[]]($output | ForEach-Object { $_.ToString() })
                  }
                  $global:LASTEXITCODE = 0
                  return [string[]]@()
                }

                $lines = New-Object System.Collections.Generic.List[string]
                $lines.Add("## Repository: $repo")
                $lines.Add("Image: $image")
                $lines.Add("")
                $lines.Add("### OS Release")
                $osRelease = Invoke-Docker -label 'OS Release' -command @('bash','-lc','if [ -f /etc/os-release ]; then cat /etc/os-release; else uname -a; fi')
                $lines.AddRange([string[]]$osRelease)
                $lines.Add("")
                $lines.Add("### dotnet --info")
                $dotnetInfo = Invoke-Docker -label '.NET info' -command @('bash','-lc','dotnet --info')
                $lines.AddRange([string[]]$dotnetInfo)
                $lines.Add("")
                $lines.Add("### pwsh --version")
                $pwshVersion = Invoke-Docker -label 'PowerShell version' -command @('bash','-lc','pwsh --version')
                $lines.AddRange([string[]]$pwshVersion)
                $lines.Add("")
                $lines.Add("### az version")
                $azVersion = Invoke-Docker -label 'Azure CLI version' -command @('bash','-lc','az --version')
                $lines.AddRange([string[]]$azVersion)
                $lines.Add("")
                $lines.Add("### zip --version (first line)")
                $zipVersion = Invoke-Docker -label 'zip version' -command @('bash','-lc','if command -v zip >/dev/null 2>&1; then zip --version | head -n 1; else echo "zip not installed"; fi')
                $lines.AddRange([string[]]$zipVersion)
                $lines.Add("")
                $lines.Add("### unzip -v (first line)")
                $unzipVersion = Invoke-Docker -label 'unzip version' -command @('bash','-lc','if command -v unzip >/dev/null 2>&1; then unzip -v | head -n 1; else echo "unzip not installed"; fi')
                $lines.AddRange([string[]]$unzipVersion)

                $reportPath = Join-Path $reportDir 'linux.md'
                $lines | Out-File -FilePath $reportPath -Encoding utf8
                Write-Host "Linux tooling report written to $reportPath"
                $global:LASTEXITCODE = 0
                return
          - task: PublishPipelineArtifact@1
            displayName: Publish Linux tooling report
            inputs:
              targetPath: $(Pipeline.Workspace)/tool-report/linux.md
              artifact: linux-tool-report

      - job: ReportWindows2022
        displayName: Capture Windows tooling inventory (2022)
        condition: and(succeeded(), eq(${{ parameters.skipWindows }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.windowsOnPremPoolName }}
          ${{ else }}:
            vmImage: windows-latest
        variables:
          EFFECTIVE_TAG_SUFFIX: $[ stageDependencies.BuildAndPublish.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          WIN_VERSION: "2022"
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: Inspect Windows image tooling (2022)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: true
              inlineScript: |
                $ErrorActionPreference = 'Stop'
                $acrFqdn = "$(ACR_NAME)"
                if([string]::IsNullOrWhiteSpace($acrFqdn)){ throw 'ACR_NAME variable empty' }
                $acrShort = $acrFqdn.Split('.')[0]
                if($acrFqdn -notmatch '\.'){
                  $acrFqdn = "$acrShort.azurecr.io"
                  Write-Host ("Normalized ACR FQDN to {0}" -f $acrFqdn)
                }
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                $skipBuildStage = [System.Convert]::ToBoolean('${{ parameters.skipBuildStage }}')
                $version = "$(WIN_VERSION)"
                if([string]::IsNullOrWhiteSpace($version)){ throw 'WIN_VERSION not provided' }
                az acr login --name $acrShort --only-show-errors | Out-Null
                $reportDir = Join-Path "$(Pipeline.Workspace)" 'tool-report'
                New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
                $lines = New-Object System.Collections.Generic.List[string]

                function Get-LatestTag([string]$acr, [string]$repository){
                  $result = az acr repository show-tags --name $acr --repository $repository --top 20 --orderby time_desc -o tsv 2>&1
                  if($LASTEXITCODE -ne 0){
                    Write-Warning ("Failed to query tags for {0}/{1}: {2}" -f $acr, $repository, ($result -join ' '))
                    return $null
                  }
                  $candidates = @()
                  foreach($line in $result){
                    if([string]::IsNullOrWhiteSpace($line)){ continue }
                    $trimmed = $line.Trim()
                    if(-not [string]::IsNullOrWhiteSpace($trimmed)){ $candidates += $trimmed }
                  }
                  if(-not $candidates){ return $null }
                  $preferred = $candidates | Where-Object { $_ -notin @('latest','Latest','LATEST') }
                  if($preferred){ return $preferred[0] }
                  return $candidates[0]
                }

                function Invoke-Container([string]$image, [string]$label, [string[]]$command) {
                  Write-Host "-- $label ($image) --"
                  $dockerArgs = @('--rm')
                  if($command -and $command.Count -gt 0){
                    $entrypoint = $command[0]
                    $dockerArgs += @('--entrypoint', $entrypoint, $image)
                    if($command.Count -gt 1){ $dockerArgs += $command[1..($command.Count-1)] }
                  }
                  else {
                    $dockerArgs += $image
                  }
                  $output = & docker run @dockerArgs 2>&1
                  $exitCode = $LASTEXITCODE
                  if ($exitCode -ne 0) {
                    Write-Warning "$label command failed with exit code $exitCode"
                    $details = @("Command: " + ($command -join ' '), "ExitCode: $exitCode")
                    if($output){ $details += ($output | ForEach-Object { $_.ToString() }) }
                    $global:LASTEXITCODE = 0
                    return [string[]]$details
                  }
                  if($output){
                    $global:LASTEXITCODE = 0
                    return [string[]]($output | ForEach-Object { $_.ToString() })
                  }
                  $global:LASTEXITCODE = 0
                  return [string[]]@()
                }

                function Add-ReportLines([object]$data) {
                  if($null -eq $data){ return }
                  if ($data -is [System.Collections.IEnumerable]) {
                    foreach ($entry in $data) {
                      if($null -ne $entry){ $lines.Add([string]$entry) }
                    }
                  }
                  else {
                    $lines.Add([string]$data)
                  }
                }

                $repo = "windows-sh-agent-$version"
                $tagToUse = $tag
                if($skipBuildStage){
                  Write-Host "skipBuildStage=true -> resolving latest tag for $repo"
                  $resolved = Get-LatestTag -acr $acrShort -repository $repo
                  if([string]::IsNullOrWhiteSpace($resolved)){
                    Write-Warning "No tags found for $repo; writing placeholder tooling capture."
                    $lines.Add("## Repository: $repo")
                    $lines.Add("Image: (not available)")
                    $lines.Add("")
                    $lines.Add("_No published tags were found in $acrShort/$repo; skipping._")
                    $lines.Add("")
                    $reportPath = Join-Path $reportDir ("windows-{0}.md" -f $version)
                    $lines | Out-File -FilePath $reportPath -Encoding utf8
                    Write-Host "Windows tooling report written to $reportPath"
                    $global:LASTEXITCODE = 0
                    return
                  }
                  $tagToUse = $resolved
                  Write-Host ("Resolved existing tag for {0}: {1}" -f $repo, $tagToUse)
                }
                elseif([string]::IsNullOrWhiteSpace($tagToUse)){
                  throw 'EFFECTIVE_TAG_SUFFIX missing (Versioning stage output unavailable).'
                }

                $image = "{0}/{1}:{2}" -f $acrFqdn, $repo, $tagToUse
                Write-Host "Inspecting Windows image $image"
                $pullOutput = & docker pull $image 2>&1
                if($LASTEXITCODE -ne 0){
                  $message = ($pullOutput | Select-Object -First 20) -join [Environment]::NewLine
                  Write-Warning ("docker pull failed for {0}: {1}" -f $image, $message)
                  $lines.Add("## Repository: $repo")
                  $lines.Add("Image: $image")
                  $lines.Add("")
                  $lines.Add("_docker pull failed:_")
                  $lines.Add('```')
                  $lines.Add($message)
                  $lines.Add('```')
                  $lines.Add("")
                  Write-Host "##vso[task.logissue type=warning]Unable to inspect $image"
                  $global:LASTEXITCODE = 0
                }
                else {
                  $pullOutput | Write-Host
                  $lines.Add("## Repository: $repo")
                  $lines.Add("Image: $image")
                  $lines.Add("")
                  $lines.Add("### OS Version")
                  $osCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' | Select-Object ProductName, DisplayVersion, CurrentBuildNumber | Format-List | Out-String"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'OS Version' -Command $osCommand)
                  $lines.Add("")
                  $lines.Add("### dotnet --info")
                  $dotnetCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files\\dotnet\\dotnet.exe' --info"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label '.NET info' -Command $dotnetCommand)
                  $lines.Add("")
                  $lines.Add("### pwsh --version")
                  $pwshCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files\\PowerShell\\7\\pwsh.exe' --version"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'PowerShell version' -Command $pwshCommand)
                  $lines.Add("")
                  $lines.Add("### az --version")
                  $azCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files (x86)\\Microsoft SDKs\\Azure\\CLI2\\wbin\\az.cmd' --version"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'Azure CLI version' -Command $azCommand)
                  $lines.Add("")
                }

                $reportPath = Join-Path $reportDir ("windows-{0}.md" -f $version)
                $lines | Out-File -FilePath $reportPath -Encoding utf8
                Write-Host "Windows tooling report written to $reportPath"
                $global:LASTEXITCODE = 0
                return
          - task: PublishPipelineArtifact@1
            displayName: Publish Windows tooling report (2022)
            inputs:
              targetPath: $(Pipeline.Workspace)/tool-report/windows-2022.md
              artifact: windows-tool-report-2022

      - job: ReportWindows2025
        displayName: Capture Windows tooling inventory (2025)
        condition: and(succeeded(), eq(${{ parameters.skipWindows }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.windowsOnPremPoolName }}
          ${{ else }}:
            vmImage: windows-latest
        variables:
          EFFECTIVE_TAG_SUFFIX: $[ stageDependencies.BuildAndPublish.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          WIN_VERSION: "2025"
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: Inspect Windows image tooling (2025)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: true
              inlineScript: |
                $ErrorActionPreference = 'Stop'
                $acrFqdn = "$(ACR_NAME)"
                if([string]::IsNullOrWhiteSpace($acrFqdn)){ throw 'ACR_NAME variable empty' }
                $acrShort = $acrFqdn.Split('.')[0]
                if($acrFqdn -notmatch '\.'){
                  $acrFqdn = "$acrShort.azurecr.io"
                  Write-Host ("Normalized ACR FQDN to {0}" -f $acrFqdn)
                }
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                $skipBuildStage = [System.Convert]::ToBoolean('${{ parameters.skipBuildStage }}')
                $version = "$(WIN_VERSION)"
                if([string]::IsNullOrWhiteSpace($version)){ throw 'WIN_VERSION not provided' }
                az acr login --name $acrShort --only-show-errors | Out-Null
                $reportDir = Join-Path "$(Pipeline.Workspace)" 'tool-report'
                New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
                $lines = New-Object System.Collections.Generic.List[string]

                function Get-LatestTag([string]$acr, [string]$repository){
                  $result = az acr repository show-tags --name $acr --repository $repository --top 20 --orderby time_desc -o tsv 2>&1
                  if($LASTEXITCODE -ne 0){
                    Write-Warning ("Failed to query tags for {0}/{1}: {2}" -f $acr, $repository, ($result -join ' '))
                    return $null
                  }
                  $candidates = @()
                  foreach($line in $result){
                    if([string]::IsNullOrWhiteSpace($line)){ continue }
                    $trimmed = $line.Trim()
                    if(-not [string]::IsNullOrWhiteSpace($trimmed)){ $candidates += $trimmed }
                  }
                  if(-not $candidates){ return $null }
                  $preferred = $candidates | Where-Object { $_ -notin @('latest','Latest','LATEST') }
                  if($preferred){ return $preferred[0] }
                  return $candidates[0]
                }

                function Invoke-Container([string]$image, [string]$label, [string[]]$command) {
                  Write-Host "-- $label ($image) --"
                  $dockerArgs = @('--rm')
                  if($command -and $command.Count -gt 0){
                    $entrypoint = $command[0]
                    $dockerArgs += @('--entrypoint', $entrypoint, $image)
                    if($command.Count -gt 1){ $dockerArgs += $command[1..($command.Count-1)] }
                  }
                  else {
                    $dockerArgs += $image
                  }
                  $output = & docker run @dockerArgs 2>&1
                  $exitCode = $LASTEXITCODE
                  if ($exitCode -ne 0) {
                    Write-Warning "$label command failed with exit code $exitCode"
                    $details = @("Command: " + ($command -join ' '), "ExitCode: $exitCode")
                    if($output){ $details += ($output | ForEach-Object { $_.ToString() }) }
                    $global:LASTEXITCODE = 0
                    return [string[]]$details
                  }
                  if($output){
                    $global:LASTEXITCODE = 0
                    return [string[]]($output | ForEach-Object { $_.ToString() })
                  }
                  $global:LASTEXITCODE = 0
                  return [string[]]@()
                }

                function Add-ReportLines([object]$data) {
                  if($null -eq $data){ return }
                  if ($data -is [System.Collections.IEnumerable]) {
                    foreach ($entry in $data) {
                      if($null -ne $entry){ $lines.Add([string]$entry) }
                    }
                  }
                  else {
                    $lines.Add([string]$data)
                  }
                }

                $repo = "windows-sh-agent-$version"
                $tagToUse = $tag
                if($skipBuildStage){
                  Write-Host "skipBuildStage=true -> resolving latest tag for $repo"
                  $resolved = Get-LatestTag -acr $acrShort -repository $repo
                  if([string]::IsNullOrWhiteSpace($resolved)){
                    Write-Warning "No tags found for $repo; writing placeholder tooling capture."
                    $lines.Add("## Repository: $repo")
                    $lines.Add("Image: (not available)")
                    $lines.Add("")
                    $lines.Add("_No published tags were found in $acrShort/$repo; skipping._")
                    $lines.Add("")
                    $reportPath = Join-Path $reportDir ("windows-{0}.md" -f $version)
                    $lines | Out-File -FilePath $reportPath -Encoding utf8
                    Write-Host "Windows tooling report written to $reportPath"
                    $global:LASTEXITCODE = 0
                    return
                  }
                  $tagToUse = $resolved
                  Write-Host ("Resolved existing tag for {0}: {1}" -f $repo, $tagToUse)
                }
                elseif([string]::IsNullOrWhiteSpace($tagToUse)){
                  throw 'EFFECTIVE_TAG_SUFFIX missing (Versioning stage output unavailable).'
                }

                $image = "{0}/{1}:{2}" -f $acrFqdn, $repo, $tagToUse
                Write-Host "Inspecting Windows image $image"
                $pullOutput = & docker pull $image 2>&1
                if($LASTEXITCODE -ne 0){
                  $message = ($pullOutput | Select-Object -First 20) -join [Environment]::NewLine
                  Write-Warning ("docker pull failed for {0}: {1}" -f $image, $message)
                  $lines.Add("## Repository: $repo")
                  $lines.Add("Image: $image")
                  $lines.Add("")
                  $lines.Add("_docker pull failed:_")
                  $lines.Add('```')
                  $lines.Add($message)
                  $lines.Add('```')
                  $lines.Add("")
                  Write-Host "##vso[task.logissue type=warning]Unable to inspect $image"
                  $global:LASTEXITCODE = 0
                }
                else {
                  $pullOutput | Write-Host
                  $lines.Add("## Repository: $repo")
                  $lines.Add("Image: $image")
                  $lines.Add("")
                  $lines.Add("### OS Version")
                  $osCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' | Select-Object ProductName, DisplayVersion, CurrentBuildNumber | Format-List | Out-String"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'OS Version' -Command $osCommand)
                  $lines.Add("")
                  $lines.Add("### dotnet --info")
                  $dotnetCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files\\dotnet\\dotnet.exe' --info"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label '.NET info' -Command $dotnetCommand)
                  $lines.Add("")
                  $lines.Add("### pwsh --version")
                  $pwshCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files\\PowerShell\\7\\pwsh.exe' --version"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'PowerShell version' -Command $pwshCommand)
                  $lines.Add("")
                  $lines.Add("### az --version")
                  $azCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files (x86)\\Microsoft SDKs\\Azure\\CLI2\\wbin\\az.cmd' --version"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'Azure CLI version' -Command $azCommand)
                  $lines.Add("")
                }

                $reportPath = Join-Path $reportDir ("windows-{0}.md" -f $version)
                $lines | Out-File -FilePath $reportPath -Encoding utf8
                Write-Host "Windows tooling report written to $reportPath"
                $global:LASTEXITCODE = 0
                return
          - task: PublishPipelineArtifact@1
            displayName: Publish Windows tooling report (2025)
            inputs:
              targetPath: $(Pipeline.Workspace)/tool-report/windows-2025.md
              artifact: windows-tool-report-2025

      - job: ReportWindowsDinD2022
        displayName: Capture Windows DinD tooling inventory (2022)
        condition: and(succeeded(), eq(${{ parameters.skipWindows }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.windowsOnPremPoolName }}
          ${{ else }}:
            vmImage: windows-latest
        variables:
          EFFECTIVE_TAG_SUFFIX: $[ stageDependencies.BuildAndPublish.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          WIN_VERSION: "2022"
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: Inspect Windows DinD image tooling (2022)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: true
              inlineScript: |
                $ErrorActionPreference = 'Stop'
                $acrFqdn = "$(ACR_NAME)"
                if([string]::IsNullOrWhiteSpace($acrFqdn)){ throw 'ACR_NAME variable empty' }
                $acrShort = $acrFqdn.Split('.')[0]
                if($acrFqdn -notmatch '\.'){
                  $acrFqdn = "$acrShort.azurecr.io"
                  Write-Host ("Normalized ACR FQDN to {0}" -f $acrFqdn)
                }
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                $skipBuildStage = [System.Convert]::ToBoolean('${{ parameters.skipBuildStage }}')
                $version = "$(WIN_VERSION)"
                if([string]::IsNullOrWhiteSpace($version)){ throw 'WIN_VERSION not provided' }
                az acr login --name $acrShort --only-show-errors | Out-Null
                $reportDir = Join-Path "$(Pipeline.Workspace)" 'tool-report'
                New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
                $lines = New-Object System.Collections.Generic.List[string]

                function Get-LatestTag([string]$acr, [string]$repository){
                  $result = az acr repository show-tags --name $acr --repository $repository --top 20 --orderby time_desc -o tsv 2>&1
                  if($LASTEXITCODE -ne 0){
                    Write-Warning ("Failed to query tags for {0}/{1}: {2}" -f $acr, $repository, ($result -join ' '))
                    return $null
                  }
                  $candidates = @()
                  foreach($line in $result){
                    if([string]::IsNullOrWhiteSpace($line)){ continue }
                    $trimmed = $line.Trim()
                    if(-not [string]::IsNullOrWhiteSpace($trimmed)){ $candidates += $trimmed }
                  }
                  if(-not $candidates){ return $null }
                  $preferred = $candidates | Where-Object { $_ -notin @('latest','Latest','LATEST') }
                  if($preferred){ return $preferred[0] }
                  return $candidates[0]
                }

                function Invoke-Container([string]$image, [string]$label, [string[]]$command) {
                  Write-Host "-- $label ($image) --"
                  $dockerArgs = @('--rm')
                  if($command -and $command.Count -gt 0){
                    $entrypoint = $command[0]
                    $dockerArgs += @('--entrypoint', $entrypoint, $image)
                    if($command.Count -gt 1){ $dockerArgs += $command[1..($command.Count-1)] }
                  }
                  else {
                    $dockerArgs += $image
                  }
                  $output = & docker run @dockerArgs 2>&1
                  $exitCode = $LASTEXITCODE
                  if ($exitCode -ne 0) {
                    Write-Warning "$label command failed with exit code $exitCode"
                    $details = @("Command: " + ($command -join ' '), "ExitCode: $exitCode")
                    if($output){ $details += ($output | ForEach-Object { $_.ToString() }) }
                    $global:LASTEXITCODE = 0
                    return [string[]]$details
                  }
                  if($output){
                    $global:LASTEXITCODE = 0
                    return [string[]]($output | ForEach-Object { $_.ToString() })
                  }
                  $global:LASTEXITCODE = 0
                  return [string[]]@()
                }

                function Add-ReportLines([object]$data) {
                  if($null -eq $data){ return }
                  if ($data -is [System.Collections.IEnumerable]) {
                    foreach ($entry in $data) {
                      if($null -ne $entry){ $lines.Add([string]$entry) }
                    }
                  }
                  else {
                    $lines.Add([string]$data)
                  }
                }

                $repo = "windows-sh-agent-$version-dind"
                $tagToUse = $tag
                if($skipBuildStage){
                  Write-Host "skipBuildStage=true -> resolving latest tag for $repo"
                  $resolved = Get-LatestTag -acr $acrShort -repository $repo
                  if([string]::IsNullOrWhiteSpace($resolved)){
                    Write-Warning "No tags found for $repo; writing placeholder tooling capture."
                    $lines.Add("## Repository: $repo")
                    $lines.Add("Image: (not available)")
                    $lines.Add("")
                    $lines.Add("_No published tags were found in $acrShort/$repo; skipping._")
                    $lines.Add("")
                    $reportPath = Join-Path $reportDir ("windows-dind-{0}.md" -f $version)
                    $lines | Out-File -FilePath $reportPath -Encoding utf8
                    Write-Host "Windows DinD tooling report written to $reportPath"
                    $global:LASTEXITCODE = 0
                    return
                  }
                  $tagToUse = $resolved
                  Write-Host ("Resolved existing tag for {0}: {1}" -f $repo, $tagToUse)
                }
                elseif([string]::IsNullOrWhiteSpace($tagToUse)){
                  throw 'EFFECTIVE_TAG_SUFFIX missing (Versioning stage output unavailable).'
                }

                $image = "{0}/{1}:{2}" -f $acrFqdn, $repo, $tagToUse
                Write-Host "Inspecting Windows DinD image $image"
                $pullOutput = & docker pull $image 2>&1
                if($LASTEXITCODE -ne 0){
                  $message = ($pullOutput | Select-Object -First 20) -join [Environment]::NewLine
                  Write-Warning ("docker pull failed for {0}: {1}" -f $image, $message)
                  $lines.Add("## Repository: $repo")
                  $lines.Add("Image: $image")
                  $lines.Add("")
                  $lines.Add("_docker pull failed:_")
                  $lines.Add('```')
                  $lines.Add($message)
                  $lines.Add('```')
                  $lines.Add("")
                  Write-Host "##vso[task.logissue type=warning]Unable to inspect $image"
                  $global:LASTEXITCODE = 0
                }
                else {
                  $pullOutput | Write-Host
                  $lines.Add("## Repository: $repo")
                  $lines.Add("Image: $image")
                  $lines.Add("")
                  $lines.Add("### OS Version")
                  $osCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' | Select-Object ProductName, DisplayVersion, CurrentBuildNumber | Format-List | Out-String"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'OS Version' -Command $osCommand)
                  $lines.Add("")
                  $lines.Add("### dotnet --info")
                  $dotnetCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files\\dotnet\\dotnet.exe' --info"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label '.NET info' -Command $dotnetCommand)
                  $lines.Add("")
                  $lines.Add("### pwsh --version")
                  $pwshCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files\\PowerShell\\7\\pwsh.exe' --version"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'PowerShell version' -Command $pwshCommand)
                  $lines.Add("")
                  $lines.Add("### az --version")
                  $azCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files (x86)\\Microsoft SDKs\\Azure\\CLI2\\wbin\\az.cmd' --version"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'Azure CLI version' -Command $azCommand)
                  $lines.Add("")
                }

                $reportPath = Join-Path $reportDir ("windows-dind-{0}.md" -f $version)
                $lines | Out-File -FilePath $reportPath -Encoding utf8
                Write-Host "Windows DinD tooling report written to $reportPath"
                $global:LASTEXITCODE = 0
                return
          - task: PublishPipelineArtifact@1
            displayName: Publish Windows DinD tooling report (2022)
            inputs:
              targetPath: $(Pipeline.Workspace)/tool-report/windows-dind-2022.md
              artifact: windows-dind-tool-report-2022

      - job: ReportWindowsDinD2025
        displayName: Capture Windows DinD tooling inventory (2025)
        condition: and(succeeded(), eq(${{ parameters.skipWindows }}, false))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.windowsOnPremPoolName }}
          ${{ else }}:
            vmImage: windows-latest
        variables:
          EFFECTIVE_TAG_SUFFIX: $[ stageDependencies.BuildAndPublish.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          WIN_VERSION: "2025"
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: Inspect Windows DinD image tooling (2025)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: pscore
              scriptLocation: inlineScript
              failOnStandardError: true
              inlineScript: |
                $ErrorActionPreference = 'Stop'
                $acrFqdn = "$(ACR_NAME)"
                if([string]::IsNullOrWhiteSpace($acrFqdn)){ throw 'ACR_NAME variable empty' }
                $acrShort = $acrFqdn.Split('.')[0]
                if($acrFqdn -notmatch '\.'){
                  $acrFqdn = "$acrShort.azurecr.io"
                  Write-Host ("Normalized ACR FQDN to {0}" -f $acrFqdn)
                }
                $tag = "$(EFFECTIVE_TAG_SUFFIX)"
                $skipBuildStage = [System.Convert]::ToBoolean('${{ parameters.skipBuildStage }}')
                $version = "$(WIN_VERSION)"
                if([string]::IsNullOrWhiteSpace($version)){ throw 'WIN_VERSION not provided' }
                az acr login --name $acrShort --only-show-errors | Out-Null
                $reportDir = Join-Path "$(Pipeline.Workspace)" 'tool-report'
                New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
                $lines = New-Object System.Collections.Generic.List[string]

                function Get-LatestTag([string]$acr, [string]$repository){
                  $result = az acr repository show-tags --name $acr --repository $repository --top 20 --orderby time_desc -o tsv 2>&1
                  if($LASTEXITCODE -ne 0){
                    Write-Warning ("Failed to query tags for {0}/{1}: {2}" -f $acr, $repository, ($result -join ' '))
                    return $null
                  }
                  $candidates = @()
                  foreach($line in $result){
                    if([string]::IsNullOrWhiteSpace($line)){ continue }
                    $trimmed = $line.Trim()
                    if(-not [string]::IsNullOrWhiteSpace($trimmed)){ $candidates += $trimmed }
                  }
                  if(-not $candidates){ return $null }
                  $preferred = $candidates | Where-Object { $_ -notin @('latest','Latest','LATEST') }
                  if($preferred){ return $preferred[0] }
                  return $candidates[0]
                }

                function Invoke-Container([string]$image, [string]$label, [string[]]$command) {
                  Write-Host "-- $label ($image) --"
                  $dockerArgs = @('--rm')
                  if($command -and $command.Count -gt 0){
                    $entrypoint = $command[0]
                    $dockerArgs += @('--entrypoint', $entrypoint, $image)
                    if($command.Count -gt 1){ $dockerArgs += $command[1..($command.Count-1)] }
                  }
                  else {
                    $dockerArgs += $image
                  }
                  $output = & docker run @dockerArgs 2>&1
                  $exitCode = $LASTEXITCODE
                  if ($exitCode -ne 0) {
                    Write-Warning "$label command failed with exit code $exitCode"
                    $details = @("Command: " + ($command -join ' '), "ExitCode: $exitCode")
                    if($output){ $details += ($output | ForEach-Object { $_.ToString() }) }
                    $global:LASTEXITCODE = 0
                    return [string[]]$details
                  }
                  if($output){
                    $global:LASTEXITCODE = 0
                    return [string[]]($output | ForEach-Object { $_.ToString() })
                  }
                  $global:LASTEXITCODE = 0
                  return [string[]]@()
                }

                function Add-ReportLines([object]$data) {
                  if($null -eq $data){ return }
                  if ($data -is [System.Collections.IEnumerable]) {
                    foreach ($entry in $data) {
                      if($null -ne $entry){ $lines.Add([string]$entry) }
                    }
                  }
                  else {
                    $lines.Add([string]$data)
                  }
                }

                $repo = "windows-sh-agent-$version-dind"
                $tagToUse = $tag
                if($skipBuildStage){
                  Write-Host "skipBuildStage=true -> resolving latest tag for $repo"
                  $resolved = Get-LatestTag -acr $acrShort -repository $repo
                  if([string]::IsNullOrWhiteSpace($resolved)){
                    Write-Warning "No tags found for $repo; writing placeholder tooling capture."
                    $lines.Add("## Repository: $repo")
                    $lines.Add("Image: (not available)")
                    $lines.Add("")
                    $lines.Add("_No published tags were found in $acrShort/$repo; skipping._")
                    $lines.Add("")
                    $reportPath = Join-Path $reportDir ("windows-dind-{0}.md" -f $version)
                    $lines | Out-File -FilePath $reportPath -Encoding utf8
                    Write-Host "Windows DinD tooling report written to $reportPath"
                    $global:LASTEXITCODE = 0
                    return
                  }
                  $tagToUse = $resolved
                  Write-Host ("Resolved existing tag for {0}: {1}" -f $repo, $tagToUse)
                }
                elseif([string]::IsNullOrWhiteSpace($tagToUse)){
                  throw 'EFFECTIVE_TAG_SUFFIX missing (Versioning stage output unavailable).'
                }

                $image = "{0}/{1}:{2}" -f $acrFqdn, $repo, $tagToUse
                Write-Host "Inspecting Windows DinD image $image"
                $pullOutput = & docker pull $image 2>&1
                if($LASTEXITCODE -ne 0){
                  $message = ($pullOutput | Select-Object -First 20) -join [Environment]::NewLine
                  Write-Warning ("docker pull failed for {0}: {1}" -f $image, $message)
                  $lines.Add("## Repository: $repo")
                  $lines.Add("Image: $image")
                  $lines.Add("")
                  $lines.Add("_docker pull failed:_")
                  $lines.Add('```')
                  $lines.Add($message)
                  $lines.Add('```')
                  $lines.Add("")
                  Write-Host "##vso[task.logissue type=warning]Unable to inspect $image"
                  $global:LASTEXITCODE = 0
                }
                else {
                  $pullOutput | Write-Host
                  $lines.Add("## Repository: $repo")
                  $lines.Add("Image: $image")
                  $lines.Add("")
                  $lines.Add("### OS Version")
                  $osCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' | Select-Object ProductName, DisplayVersion, CurrentBuildNumber | Format-List | Out-String"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'OS Version' -Command $osCommand)
                  $lines.Add("")
                  $lines.Add("### dotnet --info")
                  $dotnetCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files\\dotnet\\dotnet.exe' --info"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label '.NET info' -Command $dotnetCommand)
                  $lines.Add("")
                  $lines.Add("### pwsh --version")
                  $pwshCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files\\PowerShell\\7\\pwsh.exe' --version"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'PowerShell version' -Command $pwshCommand)
                  $lines.Add("")
                  $lines.Add("### az --version")
                  $azCommand = @(
                    'pwsh',
                    '-NoLogo',
                    '-NoProfile',
                    '-Command',
                    "& 'C:\\Program Files (x86)\\Microsoft SDKs\\Azure\\CLI2\\wbin\\az.cmd' --version"
                  )
                  Add-ReportLines (Invoke-Container -Image $image -Label 'Azure CLI version' -Command $azCommand)
                  $lines.Add("")
                }

                $reportPath = Join-Path $reportDir ("windows-dind-{0}.md" -f $version)
                $lines | Out-File -FilePath $reportPath -Encoding utf8
                Write-Host "Windows DinD tooling report written to $reportPath"
                $global:LASTEXITCODE = 0
                return
          - task: PublishPipelineArtifact@1
            displayName: Publish Windows DinD tooling report (2025)
            inputs:
              targetPath: $(Pipeline.Workspace)/tool-report/windows-dind-2025.md
              artifact: windows-dind-tool-report-2025

      - job: PublishWiki
        displayName: Publish tooling report to wiki
        dependsOn:
          - ReportLinuxImage
          - ReportWindows2022
          - ReportWindows2025
          - ReportWindowsDinD2022
          - ReportWindowsDinD2025
        condition: and(succeeded(), or(eq(${{ parameters.skipLinux }}, false), eq(${{ parameters.skipWindows }}, false)))
        pool:
          ${{ if parameters.useOnPremAgents }}:
            name: ${{ parameters.ubuntuOnPremPoolName }}
          ${{ else }}:
            vmImage: ubuntu-latest
        variables:
          EFFECTIVE_TAG_SUFFIX: $[ stageDependencies.BuildAndPublish.Versioning.outputs['SetSemVer.SEMVER_EFFECTIVE'] ]
          SEMVER_MODE: $[ stageDependencies.BuildAndPublish.Versioning.outputs['SetSemVer.SEMVER_MODE'] ]
        steps:
          - checkout: none
          - ${{ if eq(parameters.skipLinux, false) }}:
              - task: DownloadPipelineArtifact@2
                displayName: Download Linux tooling report
                inputs:
                  source: current
                  artifact: linux-tool-report
                  path: $(Pipeline.Workspace)/incoming/linux
          - ${{ if eq(parameters.skipWindows, false) }}:
              - task: DownloadPipelineArtifact@2
                displayName: Download Windows 2022 tooling report
                inputs:
                  source: current
                  artifact: windows-tool-report-2022
                  path: $(Pipeline.Workspace)/incoming/windows-2022
              - task: DownloadPipelineArtifact@2
                displayName: Download Windows 2025 tooling report
                inputs:
                  source: current
                  artifact: windows-tool-report-2025
                  path: $(Pipeline.Workspace)/incoming/windows-2025
              - task: DownloadPipelineArtifact@2
                displayName: Download Windows DinD 2022 tooling report
                inputs:
                  source: current
                  artifact: windows-dind-tool-report-2022
                  path: $(Pipeline.Workspace)/incoming/windows-dind-2022
              - task: DownloadPipelineArtifact@2
                displayName: Download Windows DinD 2025 tooling report
                inputs:
                  source: current
                  artifact: windows-dind-tool-report-2025
                  path: $(Pipeline.Workspace)/incoming/windows-dind-2025
          - pwsh: |
              $ErrorActionPreference = 'Stop'
              $reportDir = Join-Path "$(Pipeline.Workspace)" 'tool-report'
              New-Item -ItemType Directory -Force -Path $reportDir | Out-Null
              $sections = @()
              $generated = Get-Date -Format o

              if(Test-Path "$(Pipeline.Workspace)/incoming/linux/linux.md"){
                $sections += '# Linux Agent Image'
                $sections += ''
                $sections += Get-Content "$(Pipeline.Workspace)/incoming/linux/linux.md"
                $sections += ''
              }

              $windowsSections = @()
              $win2022Path = Join-Path "$(Pipeline.Workspace)/incoming/windows-2022" 'windows-2022.md'
              if(Test-Path $win2022Path){
                $windowsSections += '## Windows Agent Image (2022)'
                $windowsSections += ''
                $windowsSections += Get-Content $win2022Path
                $windowsSections += ''
              }

              $win2025Path = Join-Path "$(Pipeline.Workspace)/incoming/windows-2025" 'windows-2025.md'
              if(Test-Path $win2025Path){
                $windowsSections += '## Windows Agent Image (2025)'
                $windowsSections += ''
                $windowsSections += Get-Content $win2025Path
                $windowsSections += ''
              }

              $winDind2022Path = Join-Path "$(Pipeline.Workspace)/incoming/windows-dind-2022" 'windows-dind-2022.md'
              if(Test-Path $winDind2022Path){
                $windowsSections += '## Windows DinD Agent Image (2022)'
                $windowsSections += ''
                $windowsSections += Get-Content $winDind2022Path
                $windowsSections += ''
              }

              $winDind2025Path = Join-Path "$(Pipeline.Workspace)/incoming/windows-dind-2025" 'windows-dind-2025.md'
              if(Test-Path $winDind2025Path){
                $windowsSections += '## Windows DinD Agent Image (2025)'
                $windowsSections += ''
                $windowsSections += Get-Content $winDind2025Path
                $windowsSections += ''
              }

              if($windowsSections){
                $sections += '# Windows Agent Images'
                $sections += ''
                $sections += $windowsSections
              }

              if(-not $sections){
                Write-Warning 'No tooling sections were generated; skipping wiki publish.'
                New-Item -ItemType File -Force -Path (Join-Path $reportDir 'tooling-report.md') | Out-Null
                exit 0
              }

              $header = @(
                '# Agent Tooling Report',
                '',
                "*Generated: $generated*",
                "*Semantic Tag: $(EFFECTIVE_TAG_SUFFIX) (mode $(SEMVER_MODE))*",
                ''
              )

              $content = $header + $sections
              $reportPath = Join-Path $reportDir 'tooling-report.md'
              $content | Out-File -FilePath $reportPath -Encoding utf8
              Write-Host "Combined tooling report written to $reportPath"
            displayName: Combine tooling reports
          - pwsh: |
              $ErrorActionPreference = 'Stop'
              $wikiName = '${{ parameters.wikiName }}'
              $wikiPath = '${{ parameters.wikiPagePath }}'
              $comment = '${{ parameters.wikiUpdateMessage }}'
              if([string]::IsNullOrWhiteSpace($wikiName)){
                throw 'Parameter wikiName must be provided when publishToolReport=true.'
              }
              if([string]::IsNullOrWhiteSpace($wikiPath)){
                throw 'Parameter wikiPagePath must be provided when publishToolReport=true.'
              }
              $pat = $env:AZDO_PAT
              if([string]::IsNullOrWhiteSpace($pat)){
                throw 'AZDO_PAT secret variable is required to publish to the project wiki.'
              }
              $orgUrl = $env:SYSTEM_COLLECTIONURI
              $project = $env:SYSTEM_TEAMPROJECT
              if([string]::IsNullOrWhiteSpace($orgUrl) -or [string]::IsNullOrWhiteSpace($project)){
                throw 'SYSTEM_COLLECTIONURI or SYSTEM_TEAMPROJECT environment variable not available.'
              }
              az extension add --name azure-devops --only-show-errors --yes | Out-Null
              $loginOutput = $pat | az devops login --organization $orgUrl --only-show-errors 2>&1
              if($LASTEXITCODE -ne 0){
                throw 'Failed to authenticate with the provided AZDO_PAT.'
              }
              az devops configure --defaults organization=$orgUrl project=$project | Out-Null
              $reportPath = Join-Path "$(Pipeline.Workspace)" 'tool-report/tooling-report.md'
              if(-not (Test-Path $reportPath)){
                throw "Combined tooling report not found at $reportPath"
              }
              $versionToken = $null
              $pageExists = $false
              $showResult = $null
              try {
                $showResult = az devops wiki page show --wiki $wikiName --path $wikiPath --query eTag --output tsv --only-show-errors 2>&1
              }
              catch {
                $showResult = $null
              }
              $pageExists = ($LASTEXITCODE -eq 0)
              if($pageExists){
                if($showResult){
                  $candidate = @($showResult)[0]
                  if($candidate){
                    $versionToken = ([string]$candidate).Trim('"')
                  }
                }
                if([string]::IsNullOrWhiteSpace($versionToken)){
                  $altResult = $null
                  try {
                    $altResult = az devops wiki page show --wiki $wikiName --path $wikiPath --query id --output tsv --only-show-errors 2>&1
                  }
                  catch {
                    $altResult = $null
                  }
                  if($LASTEXITCODE -eq 0 -and $altResult){
                    $candidate = @($altResult)[0]
                    if($candidate){
                      $versionToken = ([string]$candidate).Trim('"')
                    }
                  }
                }
                if([string]::IsNullOrWhiteSpace($versionToken)){
                  throw 'Failed to determine wiki page version token required for update.'
                }
                Write-Host "Wiki page exists; updating content (version token: $versionToken)."
                az devops wiki page update --wiki $wikiName --path $wikiPath --file-path $reportPath --encoding utf-8 --comment $comment --version $versionToken --only-show-errors | Out-Null
                if($LASTEXITCODE -ne 0){
                  throw 'Failed to update wiki page.'
                }
                Write-Host 'Wiki page updated successfully.'
              }
              else {
                Write-Host 'Wiki page not found; ensuring parent pages exist before creation.'
                $normalizedPath = $wikiPath
                if([string]::IsNullOrWhiteSpace($normalizedPath)){
                  throw 'Wiki page path cannot be blank.'
                }
                if($normalizedPath.StartsWith('/')){
                  $normalizedPath = $normalizedPath.Substring(1)
                }
                $segments = $normalizedPath -split '/'
                if($segments.Length -gt 1){
                  $builtSegments = @()
                  for($i = 0; $i -lt ($segments.Length - 1); $i++){
                    $segment = $segments[$i].Trim()
                    if([string]::IsNullOrWhiteSpace($segment)){
                      continue
                    }
                    $builtSegments += $segment
                    $currentPath = '/' + ($builtSegments -join '/')
                    $parentCheck = az devops wiki page show --wiki $wikiName --path $currentPath --only-show-errors 2>&1
                    if($LASTEXITCODE -eq 0){
                      continue
                    }
                    Write-Host ("Creating wiki parent page {0}" -f $currentPath)
                    $parentContent = "# $segment"
                    $parentCreated = $false
                    for($attempt = 1; $attempt -le 3; $attempt++){
                      az devops wiki page create --wiki $wikiName --path $currentPath --content $parentContent --comment 'Automated parent page creation for tooling report' --only-show-errors | Out-Null
                      if($LASTEXITCODE -eq 0){
                        $parentCreated = $true
                        break
                      }
                      if($attempt -lt 3){
                        Write-Warning ("Parent page creation attempt {0} for {1} failed (exit {2}); retrying in 5 seconds." -f $attempt, $currentPath, $LASTEXITCODE)
                        Start-Sleep -Seconds 5
                      }
                    }
                    if(-not $parentCreated){
                      throw ("Failed to create parent wiki page {0}" -f $currentPath)
                    }
                  }
                }
                $createSucceeded = $false
                for($attempt = 1; $attempt -le 3; $attempt++){
                  az devops wiki page create --wiki $wikiName --path $wikiPath --file-path $reportPath --encoding utf-8 --comment $comment --only-show-errors | Out-Null
                  if($LASTEXITCODE -eq 0){
                    $createSucceeded = $true
                    break
                  }
                  if($attempt -lt 3){
                    Write-Warning ("Wiki page create attempt {0} failed (exit {1}); retrying in 5 seconds." -f $attempt, $LASTEXITCODE)
                    Start-Sleep -Seconds 5
                  }
                }
                if(-not $createSucceeded){
                  throw 'Failed to create wiki page.'
                }
                Write-Host 'Wiki page created successfully.'
              }
            displayName: Publish tooling report to wiki
            env:
              AZDO_PAT: $(AZDO_PAT)
          - task: PublishPipelineArtifact@1
            displayName: Publish combined tooling report
            inputs:
              targetPath: $(Pipeline.Workspace)/tool-report/tooling-report.md
              artifact: agent-tooling-report
