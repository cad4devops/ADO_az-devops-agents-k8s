# Separate pipeline to validate newly deployed self-hosted agents
# This pipeline is triggered by the completion of the deploy-selfhosted-agents pipeline as a pipeline resource.
# It downloads the 'agent-config' artifact (config.json) and uses its values to know which pools to validate.

trigger: none
pr: none

resources:
  pipelines:
    - pipeline: deployAgents
      source: ADO_az-devops-agents-k8s-deploy-self-hosted-agents
      trigger: true  # automatic trigger on successful run of source pipeline

variables:
  - group: ADO_az-devops-agents-k8s
  - name: samplePipelineName
    value: ADO_az-devops-agents-k8s-run-on-selfhosted-pool-sample # changed to full pipeline name

stages:
  - stage: Validate
    displayName: Validate self-hosted agent pools
    jobs:
      - job: LoadConfig
        displayName: Load configuration artifact
        pool:
          vmImage: ubuntu-latest
        steps:
          - download: deployAgents
            artifact: agent-config
          - task: PowerShell@2
            name: ParseConfig
            displayName: Parse config.json
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $path = Join-Path $env:PIPELINE_WORKSPACE 'deployAgents/agent-config/config.json'
                if(-not (Test-Path $path)){ throw "Config file not found at $path" }
                $cfg = Get-Content $path -Raw | ConvertFrom-Json
                Write-Host "Loaded config:" ($cfg | ConvertTo-Json -Compress)
                # Export as job output variables so downstream jobs can reference them
                Write-Host "##vso[task.setvariable variable=instanceNumber;isOutput=true]$($cfg.instanceNumber)"
                Write-Host "##vso[task.setvariable variable=deployLinux;isOutput=true]$($cfg.deployLinux)"
                Write-Host "##vso[task.setvariable variable=deployWindows;isOutput=true]$($cfg.deployWindows)"
                Write-Host "##vso[task.setvariable variable=azureDevOpsOrgUrl;isOutput=true]$($cfg.azureDevOpsOrgUrl)"
      - job: WaitLinuxPool
        displayName: Wait for Linux agent online
        dependsOn: LoadConfig
        condition: eq(dependencies.LoadConfig.outputs['ParseConfig.deployLinux'], 'True')
        pool:
          vmImage: ubuntu-latest
        variables:
          - name: instanceNumber
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.instanceNumber'] ]
          - name: azureDevOpsOrgUrl
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.azureDevOpsOrgUrl'] ]
        steps:
          - task: PowerShell@2
            displayName: Poll Linux pool
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                # Use pipeline-expanded variables (set as job variables above)
                $instance = '$(instanceNumber)'
                $orgUrl = '$(azureDevOpsOrgUrl)'
                $poolName = "KubernetesPoolLinux$instance"
                $authHeader = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(':' + $pat))
                $headers = @{ Authorization = $authHeader }
                $apiVersion = '7.1-preview.1'
                $maxSeconds = 600
                $interval = 10
                $elapsed = 0
                Write-Host "Waiting for Linux agent in pool $poolName"
                while($true){
                  $poolResp = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools?poolName=$([Uri]::EscapeDataString($poolName))&api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                  if($poolResp.count -gt 0){
                    $poolId = $poolResp.value[0].id
                    $agents = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools/$poolId/agents?api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                    $online = @($agents.value | Where-Object { $_.status -eq 'online' })
                    if($online.Count -gt 0){ Write-Host "Linux agent online: $($online[0].name)"; break }
                  }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for Linux agent" }
                  Start-Sleep -Seconds $interval; $elapsed += $interval; Write-Host "...still waiting ($elapsed s)";
                }
      - job: TestLinuxAgent
        displayName: Test validation against Linux pool (hosted runner)
        dependsOn: WaitLinuxPool
        condition: eq(dependencies.LoadConfig.outputs['ParseConfig.deployLinux'], 'True')
        pool:
          vmImage: ubuntu-latest
        variables:
          - name: instanceNumber
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.instanceNumber'] ]
          - name: azureDevOpsOrgUrl
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.azureDevOpsOrgUrl'] ]
        steps:
          - download: deployAgents
            artifact: agent-config
          - task: PowerShell@2
            displayName: Query Linux pool via REST
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                  # Read config artifact locally so we don't depend on variable expansion
                  $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgents/agent-config/config.json'
                  if(-not (Test-Path $cfgPath)){ throw "Config artifact not found at $cfgPath" }
                  $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                  $instance = $cfg.instanceNumber
                  $orgUrl = $cfg.azureDevOpsOrgUrl
                $poolName = "KubernetesPoolLinux$instance"
                $authHeader = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(':' + $pat))
                $headers = @{ Authorization = $authHeader }
                $apiVersion = '7.1-preview.1'
                Write-Host "Verifying pool '$poolName' via REST"
                $poolResp = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools?poolName=$([Uri]::EscapeDataString($poolName))&api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                if($poolResp.count -eq 0){ throw "Pool '$poolName' not found" }
                $poolId = $poolResp.value[0].id
                $agents = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools/$poolId/agents?api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                $online = @($agents.value | Where-Object { $_.status -eq 'online' })
                if($online.Count -eq 0){ throw "No online agents found in pool '$poolName'" }
                Write-Host "Linux agent online: $($online[0].name)"
          - task: PowerShell@2
            name: TriggerSample
            displayName: Trigger sample pipeline on self-hosted Linux pool
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                # Read config artifact locally so we don't depend on variable expansion
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgents/agent-config/config.json'
                if(-not (Test-Path $cfgPath)){ throw "Config artifact not found at $cfgPath" }
                $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                $instance = $cfg.instanceNumber
                $orgUrl = $cfg.azureDevOpsOrgUrl
                $project = $env:SYSTEM_TEAMPROJECT

                $pipelineName = '$(samplePipelineName)'
                Write-Host "Triggering sample pipeline '$pipelineName' for instance $instance (os=linux)"

                # Ensure az devops extension is available and configured
                $null = & az --version 2>$null
                if($LASTEXITCODE -ne 0){ throw 'Azure CLI (az) not found on PATH; unable to trigger pipeline via az CLI' }
                # Install azure-devops extension if missing
                $ext = (& az extension list --query "[?name=='azure-devops']" -o json) | ConvertFrom-Json
                if(-not $ext){ Write-Host 'Installing azure-devops extension'; az extension add --name azure-devops --yes | Out-Null }

                # Configure defaults and auth
                $env:AZURE_DEVOPS_EXT_PAT = $pat
                & az devops configure --defaults organization=$orgUrl project=$project | Out-Null

                # Queue the pipeline run with parameters (the sample pipeline defines parameters)
                $runJson = & az pipelines run --name $pipelineName --parameters instanceNumber=$instance os=linux --output json 2>&1
                if($LASTEXITCODE -ne 0){ Write-Error $runJson; throw 'Failed to queue sample pipeline run via az pipelines run' }
                $runObj = $runJson | Out-String | ConvertFrom-Json
                $runId = $runObj.id
                if(-not $runId){ throw 'Could not determine run id from az pipelines run output' }
                Write-Host "Queued pipeline run id: $runId"
                # Export run id and a best-effort run URL as step outputs so the Summary can reference them
                Write-Host "##vso[task.setvariable variable=sampleRunId;isOutput=true]$runId"
                $runUrl = "$orgUrl/$project/_build/results?buildId=$runId&view=results"
                Write-Host "##vso[task.setvariable variable=sampleRunUrl;isOutput=true]$runUrl"

                # Poll run status until finished (robust to different az output shapes)
                $state = $null; $result = $null
                while($true){
                  Start-Sleep -Seconds 5
                  $showRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                  try{
                    $showObj = $showRaw | ConvertFrom-Json
                  } catch {
                    Write-Warning "Failed to parse az pipelines runs show output: $showRaw"
                    continue
                  }
                  if($null -eq $showObj){ Write-Host 'No run information yet'; continue }
                  # az may return an object or an array
                  $info = if($showObj -is [System.Array]){ $showObj[0] } else { $showObj }
                  # prefer 'state', fall back to 'status'
                  if($info.PSObject.Properties.Name -contains 'state'){ $state = $info.state } elseif($info.PSObject.Properties.Name -contains 'status'){ $state = $info.status }
                  if($info.PSObject.Properties.Name -contains 'result'){ $result = $info.result }
                  Write-Host "Sample run state=$state result=$result"
                  if($state -in @('completed','canceled','failed')){ break }
                }
                # Fetch final run info to be sure
                $finalRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                $finalObj = $null
                try{ $finalObj = $finalRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse final run show output: $finalRaw" }
                $finalInfo = if($finalObj -is [System.Array]){ $finalObj[0] } else { $finalObj }
                $finalResult = $null
                if($finalInfo -ne $null -and $finalInfo.PSObject.Properties.Name -contains 'result'){ $finalResult = $finalInfo.result }
                if(-not $finalResult){ $finalResult = $result }
                if($finalResult -ne 'succeeded'){ throw "Sample pipeline run did not succeed (result=$finalResult)" }
      - job: WaitWindowsPool
        displayName: Wait for Windows agent online
        dependsOn: LoadConfig
        condition: eq(dependencies.LoadConfig.outputs['ParseConfig.deployWindows'], 'True')
        pool:
          vmImage: ubuntu-latest
        variables:
          - name: instanceNumber
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.instanceNumber'] ]
          - name: azureDevOpsOrgUrl
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.azureDevOpsOrgUrl'] ]
        steps:
          - task: PowerShell@2
            displayName: Poll Windows pool
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                # Use pipeline-expanded variables (set as job variables above)
                $instance = '$(instanceNumber)'
                $orgUrl = '$(azureDevOpsOrgUrl)'
                $poolName = "KubernetesPoolWindows$instance"
                $authHeader = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(':' + $pat))
                $headers = @{ Authorization = $authHeader }
                $apiVersion = '7.1-preview.1'
                $maxSeconds = 900
                $interval = 15
                $elapsed = 0
                Write-Host "Waiting for Windows agent in pool $poolName"
                while($true){
                  $poolResp = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools?poolName=$([Uri]::EscapeDataString($poolName))&api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                  if($poolResp.count -gt 0){
                    $poolId = $poolResp.value[0].id
                    $agents = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools/$poolId/agents?api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                    $online = @($agents.value | Where-Object { $_.status -eq 'online' })
                    if($online.Count -gt 0){ Write-Host "Windows agent online: $($online[0].name)"; break }
                  }
                  if($elapsed -ge $maxSeconds){ throw "Timed out waiting for Windows agent" }
                  Start-Sleep -Seconds $interval; $elapsed += $interval; Write-Host "...still waiting ($elapsed s)";
                }
      - job: TestWindowsAgent
        displayName: Test validation against Windows pool (hosted runner)
        dependsOn: WaitWindowsPool
        condition: eq(dependencies.LoadConfig.outputs['ParseConfig.deployWindows'], 'True')
        pool:
          vmImage: ubuntu-latest
        variables:
          - name: instanceNumber
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.instanceNumber'] ]
          - name: azureDevOpsOrgUrl
            value: $[ dependencies.LoadConfig.outputs['ParseConfig.azureDevOpsOrgUrl'] ]
        steps:
          - download: deployAgents
            artifact: agent-config
          - task: PowerShell@2
            displayName: Query Windows pool via REST
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                  $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgents/agent-config/config.json'
                  if(-not (Test-Path $cfgPath)){ throw "Config artifact not found at $cfgPath" }
                  $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                  $instance = $cfg.instanceNumber
                  $orgUrl = $cfg.azureDevOpsOrgUrl
                $poolName = "KubernetesPoolWindows$instance"
                $authHeader = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(':' + $pat))
                $headers = @{ Authorization = $authHeader }
                $apiVersion = '7.1-preview.1'
                Write-Host "Verifying pool '$poolName' via REST"
                $poolResp = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools?poolName=$([Uri]::EscapeDataString($poolName))&api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                if($poolResp.count -eq 0){ throw "Pool '$poolName' not found" }
                $poolId = $poolResp.value[0].id
                $agents = Invoke-RestMethod -Method Get -Uri "$orgUrl/_apis/distributedtask/pools/$poolId/agents?api-version=$apiVersion" -Headers $headers -ErrorAction Stop
                $online = @($agents.value | Where-Object { $_.status -eq 'online' })
                if($online.Count -eq 0){ throw "No online agents found in pool '$poolName'" }
                Write-Host "Windows agent online: $($online[0].name)"
          - task: PowerShell@2
            name: TriggerSample
            displayName: Trigger sample pipeline on self-hosted Windows pool
            env:
              AZDO_PAT: $(AZDO_PAT)
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $ErrorActionPreference = 'Stop'
                $pat = $env:AZDO_PAT
                if(-not $pat){ throw 'AZDO_PAT missing' }
                # Read config artifact locally so we don't depend on variable expansion
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgents/agent-config/config.json'
                if(-not (Test-Path $cfgPath)){ throw "Config artifact not found at $cfgPath" }
                $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                $instance = $cfg.instanceNumber
                $orgUrl = $cfg.azureDevOpsOrgUrl
                $project = $env:SYSTEM_TEAMPROJECT

                $pipelineName = '$(samplePipelineName)'
                Write-Host "Triggering sample pipeline '$pipelineName' for instance $instance (os=windows)"

                # Ensure az devops extension is available and configured
                $null = & az --version 2>$null
                if($LASTEXITCODE -ne 0){ throw 'Azure CLI (az) not found on PATH; unable to trigger pipeline via az CLI' }
                # Install azure-devops extension if missing
                $ext = (& az extension list --query "[?name=='azure-devops']" -o json) | ConvertFrom-Json
                if(-not $ext){ Write-Host 'Installing azure-devops extension'; az extension add --name azure-devops --yes | Out-Null }

                # Configure defaults and auth
                $env:AZURE_DEVOPS_EXT_PAT = $pat
                & az devops configure --defaults organization=$orgUrl project=$project | Out-Null

                # Queue the pipeline run with parameters (the sample pipeline defines parameters)
                $runJson = & az pipelines run --name $pipelineName --parameters instanceNumber=$instance os=windows --output json 2>&1
                if($LASTEXITCODE -ne 0){ Write-Error $runJson; throw 'Failed to queue sample pipeline run via az pipelines run' }
                $runObj = $runJson | Out-String | ConvertFrom-Json
                $runId = $runObj.id
                if(-not $runId){ throw 'Could not determine run id from az pipelines run output' }
                Write-Host "Queued pipeline run id: $runId"
                # Export run id and a best-effort run URL as step outputs so the Summary can reference them
                Write-Host "##vso[task.setvariable variable=sampleRunId;isOutput=true]$runId"
                $runUrl = "$orgUrl/$project/_build/results?buildId=$runId&view=results"
                Write-Host "##vso[task.setvariable variable=sampleRunUrl;isOutput=true]$runUrl"

                # Poll run status until finished (robust to different az output shapes)
                $state = $null; $result = $null
                while($true){
                  Start-Sleep -Seconds 5
                  $showRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                  try{
                    $showObj = $showRaw | ConvertFrom-Json
                  } catch {
                    Write-Warning "Failed to parse az pipelines runs show output: $showRaw"
                    continue
                  }
                  if($null -eq $showObj){ Write-Host 'No run information yet'; continue }
                  # az may return an object or an array
                  $info = if($showObj -is [System.Array]){ $showObj[0] } else { $showObj }
                  # prefer 'state', fall back to 'status'
                  if($info.PSObject.Properties.Name -contains 'state'){ $state = $info.state } elseif($info.PSObject.Properties.Name -contains 'status'){ $state = $info.status }
                  if($info.PSObject.Properties.Name -contains 'result'){ $result = $info.result }
                  Write-Host "Sample run state=$state result=$result"
                  if($state -in @('completed','canceled','failed')){ break }
                }
                # Fetch final run info to be sure
                $finalRaw = & az pipelines runs show --id $runId --output json 2>&1 | Out-String
                $finalObj = $null
                try{ $finalObj = $finalRaw | ConvertFrom-Json } catch { Write-Warning "Failed to parse final run show output: $finalRaw" }
                $finalInfo = if($finalObj -is [System.Array]){ $finalObj[0] } else { $finalObj }
                $finalResult = $null
                if($finalInfo -ne $null -and $finalInfo.PSObject.Properties.Name -contains 'result'){ $finalResult = $finalInfo.result }
                if(-not $finalResult){ $finalResult = $result }
                if($finalResult -ne 'succeeded'){ throw "Sample pipeline run did not succeed (result=$finalResult)" }
      - job: Summary
        displayName: Validation Summary
        dependsOn:
          - TestLinuxAgent
          - TestWindowsAgent
        condition: succeededOrFailed()
        pool:
          vmImage: ubuntu-latest
        variables:
          - name: linuxResult
            value: $[ dependencies.TestLinuxAgent.result ]
          - name: windowsResult
            value: $[ dependencies.TestWindowsAgent.result ]
          - name: linuxRunId
            value: $[ dependencies.TestLinuxAgent.outputs['TriggerSample.sampleRunId'] ]
          - name: linuxRunUrl
            value: $[ dependencies.TestLinuxAgent.outputs['TriggerSample.sampleRunUrl'] ]
          - name: windowsRunId
            value: $[ dependencies.TestWindowsAgent.outputs['TriggerSample.sampleRunId'] ]
          - name: windowsRunUrl
            value: $[ dependencies.TestWindowsAgent.outputs['TriggerSample.sampleRunUrl'] ]
        steps:
          - download: deployAgents
            artifact: agent-config
          - task: PowerShell@2
            displayName: Emit validation summary
            inputs:
              targetType: inline
              pwsh: true
              script: |
                Set-StrictMode -Version Latest
                $cfgPath = Join-Path $env:PIPELINE_WORKSPACE 'deployAgents/agent-config/config.json'
                $instance = 'unknown'
                $deployLinux = 'False'
                $deployWindows = 'False'
                $org = ''
                if(Test-Path $cfgPath){
                  $cfg = Get-Content $cfgPath -Raw | ConvertFrom-Json
                  $instance = $cfg.instanceNumber
                  $deployLinux = $cfg.deployLinux
                  $deployWindows = $cfg.deployWindows
                  $org = $cfg.azureDevOpsOrgUrl
                }

                $linuxRes = '$(linuxResult)'
                $winRes = '$(windowsResult)'
                $linuxRunId = '$(linuxRunId)'
                $linuxRunUrl = '$(linuxRunUrl)'
                $windowsRunId = '$(windowsRunId)'
                $windowsRunUrl = '$(windowsRunUrl)'

                $lines = @('# Validation Summary', "Instance: $instance", "Azure DevOps Org: $org")
                if($deployLinux -eq $true -or $deployLinux -eq 'True'){ 
                  $lines += "Linux test result: $linuxRes"
                  if($linuxRunId){ $lines += "Linux sample run id: $linuxRunId" }
                  if($linuxRunUrl){ $lines += "Linux sample run URL: $linuxRunUrl" }
                } else { $lines += 'Linux deployment skipped' }
                if($deployWindows -eq $true -or $deployWindows -eq 'True'){
                  $lines += "Windows test result: $winRes"
                  if($windowsRunId){ $lines += "Windows sample run id: $windowsRunId" }
                  if($windowsRunUrl){ $lines += "Windows sample run URL: $windowsRunUrl" }
                } else { $lines += 'Windows deployment skipped' }

                $out = Join-Path $env:SYSTEM_DEFAULTWORKINGDIRECTORY 'validation-summary.md'
                $lines | Out-File $out -Encoding utf8
                Write-Host "##vso[task.addattachment type=Distributedtask.Core.Summary;name=Agent Validation]$out"
                $lines | ForEach-Object { Write-Host $_ }
